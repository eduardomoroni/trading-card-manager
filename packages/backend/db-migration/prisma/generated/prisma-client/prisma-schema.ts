// Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateCard {
  count: Int!
}

type AggregatePrinting {
  count: Int!
}

type AggregateSet {
  count: Int!
}

type AggregateSubType {
  count: Int!
}

type AggregateSuperType {
  count: Int!
}

type AggregateToken {
  count: Int!
}

type AggregateType {
  count: Int!
}

type BatchPayload {
  count: Long!
}

enum BorderColor {
  BLACK
}

type Card {
  id: ID!
  set: Set!
  uuid: String!
  artist: String!
  colorIdentities: [Color!]!
  colors: [Color!]!
  layout: Layout!
  name: String!
  number: String!
  power: String
  toughness: String
  text: String
  type: String!
  watermark: String
  convertedManaCost: Float!
  flavorText: String
  foreignData: [ForeignData!]
  manaCost: String!
  multiverseId: Int!
  rarity: Rarity!
  rulings: [Ruling!]
  printings(where: PrintingWhereInput, orderBy: PrintingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Printing!]
  subTypes(where: SubTypeWhereInput, orderBy: SubTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubType!]
  superTypes(where: SuperTypeWhereInput, orderBy: SuperTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SuperType!]
  types(where: TypeWhereInput, orderBy: TypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Type!]
  legalities: Json
}

type CardConnection {
  pageInfo: PageInfo!
  edges: [CardEdge]!
  aggregate: AggregateCard!
}

input CardCreatecolorIdentitiesInput {
  set: [Color!]
}

input CardCreatecolorsInput {
  set: [Color!]
}

input CardCreateInput {
  id: ID
  set: SetCreateOneWithoutCardsInput!
  uuid: String!
  artist: String!
  colorIdentities: CardCreatecolorIdentitiesInput
  colors: CardCreatecolorsInput
  layout: Layout!
  name: String!
  number: String!
  power: String
  toughness: String
  text: String
  type: String!
  watermark: String
  convertedManaCost: Float
  flavorText: String
  foreignData: ForeignDataCreateManyInput
  manaCost: String
  multiverseId: Int!
  rarity: Rarity!
  rulings: RulingCreateManyInput
  printings: PrintingCreateManyInput
  subTypes: SubTypeCreateManyInput
  superTypes: SuperTypeCreateManyInput
  types: TypeCreateManyInput
  legalities: Json
}

input CardCreateManyWithoutSetInput {
  create: [CardCreateWithoutSetInput!]
  connect: [CardWhereUniqueInput!]
}

input CardCreateWithoutSetInput {
  id: ID
  uuid: String!
  artist: String!
  colorIdentities: CardCreatecolorIdentitiesInput
  colors: CardCreatecolorsInput
  layout: Layout!
  name: String!
  number: String!
  power: String
  toughness: String
  text: String
  type: String!
  watermark: String
  convertedManaCost: Float
  flavorText: String
  foreignData: ForeignDataCreateManyInput
  manaCost: String
  multiverseId: Int!
  rarity: Rarity!
  rulings: RulingCreateManyInput
  printings: PrintingCreateManyInput
  subTypes: SubTypeCreateManyInput
  superTypes: SuperTypeCreateManyInput
  types: TypeCreateManyInput
  legalities: Json
}

type CardEdge {
  node: Card!
  cursor: String!
}

enum CardOrderByInput {
  id_ASC
  id_DESC
  uuid_ASC
  uuid_DESC
  artist_ASC
  artist_DESC
  layout_ASC
  layout_DESC
  name_ASC
  name_DESC
  number_ASC
  number_DESC
  power_ASC
  power_DESC
  toughness_ASC
  toughness_DESC
  text_ASC
  text_DESC
  type_ASC
  type_DESC
  watermark_ASC
  watermark_DESC
  convertedManaCost_ASC
  convertedManaCost_DESC
  flavorText_ASC
  flavorText_DESC
  manaCost_ASC
  manaCost_DESC
  multiverseId_ASC
  multiverseId_DESC
  rarity_ASC
  rarity_DESC
  legalities_ASC
  legalities_DESC
}

type CardPreviousValues {
  id: ID!
  uuid: String!
  artist: String!
  colorIdentities: [Color!]!
  colors: [Color!]!
  layout: Layout!
  name: String!
  number: String!
  power: String
  toughness: String
  text: String
  type: String!
  watermark: String
  convertedManaCost: Float!
  flavorText: String
  manaCost: String!
  multiverseId: Int!
  rarity: Rarity!
  legalities: Json
}

input CardScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  uuid: String
  uuid_not: String
  uuid_in: [String!]
  uuid_not_in: [String!]
  uuid_lt: String
  uuid_lte: String
  uuid_gt: String
  uuid_gte: String
  uuid_contains: String
  uuid_not_contains: String
  uuid_starts_with: String
  uuid_not_starts_with: String
  uuid_ends_with: String
  uuid_not_ends_with: String
  artist: String
  artist_not: String
  artist_in: [String!]
  artist_not_in: [String!]
  artist_lt: String
  artist_lte: String
  artist_gt: String
  artist_gte: String
  artist_contains: String
  artist_not_contains: String
  artist_starts_with: String
  artist_not_starts_with: String
  artist_ends_with: String
  artist_not_ends_with: String
  layout: Layout
  layout_not: Layout
  layout_in: [Layout!]
  layout_not_in: [Layout!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  number: String
  number_not: String
  number_in: [String!]
  number_not_in: [String!]
  number_lt: String
  number_lte: String
  number_gt: String
  number_gte: String
  number_contains: String
  number_not_contains: String
  number_starts_with: String
  number_not_starts_with: String
  number_ends_with: String
  number_not_ends_with: String
  power: String
  power_not: String
  power_in: [String!]
  power_not_in: [String!]
  power_lt: String
  power_lte: String
  power_gt: String
  power_gte: String
  power_contains: String
  power_not_contains: String
  power_starts_with: String
  power_not_starts_with: String
  power_ends_with: String
  power_not_ends_with: String
  toughness: String
  toughness_not: String
  toughness_in: [String!]
  toughness_not_in: [String!]
  toughness_lt: String
  toughness_lte: String
  toughness_gt: String
  toughness_gte: String
  toughness_contains: String
  toughness_not_contains: String
  toughness_starts_with: String
  toughness_not_starts_with: String
  toughness_ends_with: String
  toughness_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  watermark: String
  watermark_not: String
  watermark_in: [String!]
  watermark_not_in: [String!]
  watermark_lt: String
  watermark_lte: String
  watermark_gt: String
  watermark_gte: String
  watermark_contains: String
  watermark_not_contains: String
  watermark_starts_with: String
  watermark_not_starts_with: String
  watermark_ends_with: String
  watermark_not_ends_with: String
  convertedManaCost: Float
  convertedManaCost_not: Float
  convertedManaCost_in: [Float!]
  convertedManaCost_not_in: [Float!]
  convertedManaCost_lt: Float
  convertedManaCost_lte: Float
  convertedManaCost_gt: Float
  convertedManaCost_gte: Float
  flavorText: String
  flavorText_not: String
  flavorText_in: [String!]
  flavorText_not_in: [String!]
  flavorText_lt: String
  flavorText_lte: String
  flavorText_gt: String
  flavorText_gte: String
  flavorText_contains: String
  flavorText_not_contains: String
  flavorText_starts_with: String
  flavorText_not_starts_with: String
  flavorText_ends_with: String
  flavorText_not_ends_with: String
  manaCost: String
  manaCost_not: String
  manaCost_in: [String!]
  manaCost_not_in: [String!]
  manaCost_lt: String
  manaCost_lte: String
  manaCost_gt: String
  manaCost_gte: String
  manaCost_contains: String
  manaCost_not_contains: String
  manaCost_starts_with: String
  manaCost_not_starts_with: String
  manaCost_ends_with: String
  manaCost_not_ends_with: String
  multiverseId: Int
  multiverseId_not: Int
  multiverseId_in: [Int!]
  multiverseId_not_in: [Int!]
  multiverseId_lt: Int
  multiverseId_lte: Int
  multiverseId_gt: Int
  multiverseId_gte: Int
  rarity: Rarity
  rarity_not: Rarity
  rarity_in: [Rarity!]
  rarity_not_in: [Rarity!]
  AND: [CardScalarWhereInput!]
  OR: [CardScalarWhereInput!]
  NOT: [CardScalarWhereInput!]
}

type CardSubscriptionPayload {
  mutation: MutationType!
  node: Card
  updatedFields: [String!]
  previousValues: CardPreviousValues
}

input CardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CardWhereInput
  AND: [CardSubscriptionWhereInput!]
}

input CardUpdatecolorIdentitiesInput {
  set: [Color!]
}

input CardUpdatecolorsInput {
  set: [Color!]
}

input CardUpdateInput {
  set: SetUpdateOneRequiredWithoutCardsInput
  uuid: String
  artist: String
  colorIdentities: CardUpdatecolorIdentitiesInput
  colors: CardUpdatecolorsInput
  layout: Layout
  name: String
  number: String
  power: String
  toughness: String
  text: String
  type: String
  watermark: String
  convertedManaCost: Float
  flavorText: String
  foreignData: ForeignDataUpdateManyInput
  manaCost: String
  multiverseId: Int
  rarity: Rarity
  rulings: RulingUpdateManyInput
  printings: PrintingUpdateManyInput
  subTypes: SubTypeUpdateManyInput
  superTypes: SuperTypeUpdateManyInput
  types: TypeUpdateManyInput
  legalities: Json
}

input CardUpdateManyDataInput {
  uuid: String
  artist: String
  colorIdentities: CardUpdatecolorIdentitiesInput
  colors: CardUpdatecolorsInput
  layout: Layout
  name: String
  number: String
  power: String
  toughness: String
  text: String
  type: String
  watermark: String
  convertedManaCost: Float
  flavorText: String
  manaCost: String
  multiverseId: Int
  rarity: Rarity
  legalities: Json
}

input CardUpdateManyMutationInput {
  uuid: String
  artist: String
  colorIdentities: CardUpdatecolorIdentitiesInput
  colors: CardUpdatecolorsInput
  layout: Layout
  name: String
  number: String
  power: String
  toughness: String
  text: String
  type: String
  watermark: String
  convertedManaCost: Float
  flavorText: String
  manaCost: String
  multiverseId: Int
  rarity: Rarity
  legalities: Json
}

input CardUpdateManyWithoutSetInput {
  create: [CardCreateWithoutSetInput!]
  delete: [CardWhereUniqueInput!]
  connect: [CardWhereUniqueInput!]
  set: [CardWhereUniqueInput!]
  disconnect: [CardWhereUniqueInput!]
  update: [CardUpdateWithWhereUniqueWithoutSetInput!]
  upsert: [CardUpsertWithWhereUniqueWithoutSetInput!]
  deleteMany: [CardScalarWhereInput!]
  updateMany: [CardUpdateManyWithWhereNestedInput!]
}

input CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput!
  data: CardUpdateManyDataInput!
}

input CardUpdateWithoutSetDataInput {
  uuid: String
  artist: String
  colorIdentities: CardUpdatecolorIdentitiesInput
  colors: CardUpdatecolorsInput
  layout: Layout
  name: String
  number: String
  power: String
  toughness: String
  text: String
  type: String
  watermark: String
  convertedManaCost: Float
  flavorText: String
  foreignData: ForeignDataUpdateManyInput
  manaCost: String
  multiverseId: Int
  rarity: Rarity
  rulings: RulingUpdateManyInput
  printings: PrintingUpdateManyInput
  subTypes: SubTypeUpdateManyInput
  superTypes: SuperTypeUpdateManyInput
  types: TypeUpdateManyInput
  legalities: Json
}

input CardUpdateWithWhereUniqueWithoutSetInput {
  where: CardWhereUniqueInput!
  data: CardUpdateWithoutSetDataInput!
}

input CardUpsertWithWhereUniqueWithoutSetInput {
  where: CardWhereUniqueInput!
  update: CardUpdateWithoutSetDataInput!
  create: CardCreateWithoutSetInput!
}

input CardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  set: SetWhereInput
  uuid: String
  uuid_not: String
  uuid_in: [String!]
  uuid_not_in: [String!]
  uuid_lt: String
  uuid_lte: String
  uuid_gt: String
  uuid_gte: String
  uuid_contains: String
  uuid_not_contains: String
  uuid_starts_with: String
  uuid_not_starts_with: String
  uuid_ends_with: String
  uuid_not_ends_with: String
  artist: String
  artist_not: String
  artist_in: [String!]
  artist_not_in: [String!]
  artist_lt: String
  artist_lte: String
  artist_gt: String
  artist_gte: String
  artist_contains: String
  artist_not_contains: String
  artist_starts_with: String
  artist_not_starts_with: String
  artist_ends_with: String
  artist_not_ends_with: String
  layout: Layout
  layout_not: Layout
  layout_in: [Layout!]
  layout_not_in: [Layout!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  number: String
  number_not: String
  number_in: [String!]
  number_not_in: [String!]
  number_lt: String
  number_lte: String
  number_gt: String
  number_gte: String
  number_contains: String
  number_not_contains: String
  number_starts_with: String
  number_not_starts_with: String
  number_ends_with: String
  number_not_ends_with: String
  power: String
  power_not: String
  power_in: [String!]
  power_not_in: [String!]
  power_lt: String
  power_lte: String
  power_gt: String
  power_gte: String
  power_contains: String
  power_not_contains: String
  power_starts_with: String
  power_not_starts_with: String
  power_ends_with: String
  power_not_ends_with: String
  toughness: String
  toughness_not: String
  toughness_in: [String!]
  toughness_not_in: [String!]
  toughness_lt: String
  toughness_lte: String
  toughness_gt: String
  toughness_gte: String
  toughness_contains: String
  toughness_not_contains: String
  toughness_starts_with: String
  toughness_not_starts_with: String
  toughness_ends_with: String
  toughness_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  watermark: String
  watermark_not: String
  watermark_in: [String!]
  watermark_not_in: [String!]
  watermark_lt: String
  watermark_lte: String
  watermark_gt: String
  watermark_gte: String
  watermark_contains: String
  watermark_not_contains: String
  watermark_starts_with: String
  watermark_not_starts_with: String
  watermark_ends_with: String
  watermark_not_ends_with: String
  convertedManaCost: Float
  convertedManaCost_not: Float
  convertedManaCost_in: [Float!]
  convertedManaCost_not_in: [Float!]
  convertedManaCost_lt: Float
  convertedManaCost_lte: Float
  convertedManaCost_gt: Float
  convertedManaCost_gte: Float
  flavorText: String
  flavorText_not: String
  flavorText_in: [String!]
  flavorText_not_in: [String!]
  flavorText_lt: String
  flavorText_lte: String
  flavorText_gt: String
  flavorText_gte: String
  flavorText_contains: String
  flavorText_not_contains: String
  flavorText_starts_with: String
  flavorText_not_starts_with: String
  flavorText_ends_with: String
  flavorText_not_ends_with: String
  foreignData_some: ForeignDataWhereInput
  foreignData_every: ForeignDataRestrictedWhereInput
  foreignData_none: ForeignDataRestrictedWhereInput
  manaCost: String
  manaCost_not: String
  manaCost_in: [String!]
  manaCost_not_in: [String!]
  manaCost_lt: String
  manaCost_lte: String
  manaCost_gt: String
  manaCost_gte: String
  manaCost_contains: String
  manaCost_not_contains: String
  manaCost_starts_with: String
  manaCost_not_starts_with: String
  manaCost_ends_with: String
  manaCost_not_ends_with: String
  multiverseId: Int
  multiverseId_not: Int
  multiverseId_in: [Int!]
  multiverseId_not_in: [Int!]
  multiverseId_lt: Int
  multiverseId_lte: Int
  multiverseId_gt: Int
  multiverseId_gte: Int
  rarity: Rarity
  rarity_not: Rarity
  rarity_in: [Rarity!]
  rarity_not_in: [Rarity!]
  rulings_some: RulingWhereInput
  rulings_every: RulingRestrictedWhereInput
  rulings_none: RulingRestrictedWhereInput
  printings_some: PrintingWhereInput
  subTypes_some: SubTypeWhereInput
  superTypes_some: SuperTypeWhereInput
  types_some: TypeWhereInput
  AND: [CardWhereInput!]
}

input CardWhereUniqueInput {
  id: ID
  uuid: String
}

enum Color {
  G
  R
  W
  B
  U
}

scalar DateTime

type ForeignData {
  id: ID!
  multiverseId: Int!
  flavorText: String
  language: String!
  name: String!
  text: String
  type: String
  layout: Layout
}

input ForeignDataCreateInput {
  id: ID
  multiverseId: Int!
  flavorText: String
  language: String!
  name: String!
  text: String
  type: String
  layout: Layout
}

input ForeignDataCreateManyInput {
  create: [ForeignDataCreateInput!]
}

input ForeignDataRestrictedWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  multiverseId: Int
  multiverseId_not: Int
  multiverseId_in: [Int!]
  multiverseId_not_in: [Int!]
  multiverseId_lt: Int
  multiverseId_lte: Int
  multiverseId_gt: Int
  multiverseId_gte: Int
  flavorText: String
  flavorText_not: String
  flavorText_in: [String!]
  flavorText_not_in: [String!]
  flavorText_lt: String
  flavorText_lte: String
  flavorText_gt: String
  flavorText_gte: String
  flavorText_contains: String
  flavorText_not_contains: String
  flavorText_starts_with: String
  flavorText_not_starts_with: String
  flavorText_ends_with: String
  flavorText_not_ends_with: String
  language: String
  language_not: String
  language_in: [String!]
  language_not_in: [String!]
  language_lt: String
  language_lte: String
  language_gt: String
  language_gte: String
  language_contains: String
  language_not_contains: String
  language_starts_with: String
  language_not_starts_with: String
  language_ends_with: String
  language_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  layout: Layout
  layout_not: Layout
  layout_in: [Layout!]
  layout_not_in: [Layout!]
  AND: [ForeignDataRestrictedWhereInput!]
}

input ForeignDataScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  multiverseId: Int
  multiverseId_not: Int
  multiverseId_in: [Int!]
  multiverseId_not_in: [Int!]
  multiverseId_lt: Int
  multiverseId_lte: Int
  multiverseId_gt: Int
  multiverseId_gte: Int
  flavorText: String
  flavorText_not: String
  flavorText_in: [String!]
  flavorText_not_in: [String!]
  flavorText_lt: String
  flavorText_lte: String
  flavorText_gt: String
  flavorText_gte: String
  flavorText_contains: String
  flavorText_not_contains: String
  flavorText_starts_with: String
  flavorText_not_starts_with: String
  flavorText_ends_with: String
  flavorText_not_ends_with: String
  language: String
  language_not: String
  language_in: [String!]
  language_not_in: [String!]
  language_lt: String
  language_lte: String
  language_gt: String
  language_gte: String
  language_contains: String
  language_not_contains: String
  language_starts_with: String
  language_not_starts_with: String
  language_ends_with: String
  language_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  layout: Layout
  layout_not: Layout
  layout_in: [Layout!]
  layout_not_in: [Layout!]
  AND: [ForeignDataScalarWhereInput!]
  OR: [ForeignDataScalarWhereInput!]
  NOT: [ForeignDataScalarWhereInput!]
}

input ForeignDataUpdateDataInput {
  multiverseId: Int
  flavorText: String
  language: String
  name: String
  text: String
  type: String
  layout: Layout
}

input ForeignDataUpdateManyDataInput {
  multiverseId: Int
  flavorText: String
  language: String
  name: String
  text: String
  type: String
  layout: Layout
}

input ForeignDataUpdateManyInput {
  create: [ForeignDataCreateInput!]
  update: [ForeignDataUpdateWithWhereUniqueNestedInput!]
  upsert: [ForeignDataUpsertWithWhereUniqueNestedInput!]
  delete: [ForeignDataWhereUniqueInput!]
  deleteMany: [ForeignDataScalarWhereInput!]
  updateMany: [ForeignDataUpdateManyWithWhereNestedInput!]
}

input ForeignDataUpdateManyWithWhereNestedInput {
  where: ForeignDataScalarWhereInput!
  data: ForeignDataUpdateManyDataInput!
}

input ForeignDataUpdateWithWhereUniqueNestedInput {
  where: ForeignDataWhereUniqueInput!
  data: ForeignDataUpdateDataInput!
}

input ForeignDataUpsertWithWhereUniqueNestedInput {
  where: ForeignDataWhereUniqueInput!
  update: ForeignDataUpdateDataInput!
  create: ForeignDataCreateInput!
}

input ForeignDataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  multiverseId: Int
  multiverseId_not: Int
  multiverseId_in: [Int!]
  multiverseId_not_in: [Int!]
  multiverseId_lt: Int
  multiverseId_lte: Int
  multiverseId_gt: Int
  multiverseId_gte: Int
  flavorText: String
  flavorText_not: String
  flavorText_in: [String!]
  flavorText_not_in: [String!]
  flavorText_lt: String
  flavorText_lte: String
  flavorText_gt: String
  flavorText_gte: String
  flavorText_contains: String
  flavorText_not_contains: String
  flavorText_starts_with: String
  flavorText_not_starts_with: String
  flavorText_ends_with: String
  flavorText_not_ends_with: String
  language: String
  language_not: String
  language_in: [String!]
  language_not_in: [String!]
  language_lt: String
  language_lte: String
  language_gt: String
  language_gte: String
  language_contains: String
  language_not_contains: String
  language_starts_with: String
  language_not_starts_with: String
  language_ends_with: String
  language_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  layout: Layout
  layout_not: Layout
  layout_in: [Layout!]
  layout_not_in: [Layout!]
  AND: [ForeignDataWhereInput!]
}

input ForeignDataWhereUniqueInput {
  id: ID
}

scalar Json

enum Layout {
  NORMAL
}

scalar Long

type Mutation {
  createCard(data: CardCreateInput!): Card!
  updateCard(data: CardUpdateInput!, where: CardWhereUniqueInput!): Card
  updateManyCards(data: CardUpdateManyMutationInput!, where: CardWhereInput): BatchPayload!
  upsertCard(where: CardWhereUniqueInput!, create: CardCreateInput!, update: CardUpdateInput!): Card!
  deleteCard(where: CardWhereUniqueInput!): Card
  deleteManyCards(where: CardWhereInput): BatchPayload!
  createPrinting(data: PrintingCreateInput!): Printing!
  updatePrinting(data: PrintingUpdateInput!, where: PrintingWhereUniqueInput!): Printing
  updateManyPrintings(data: PrintingUpdateManyMutationInput!, where: PrintingWhereInput): BatchPayload!
  upsertPrinting(where: PrintingWhereUniqueInput!, create: PrintingCreateInput!, update: PrintingUpdateInput!): Printing!
  deletePrinting(where: PrintingWhereUniqueInput!): Printing
  deleteManyPrintings(where: PrintingWhereInput): BatchPayload!
  createSet(data: SetCreateInput!): Set!
  updateSet(data: SetUpdateInput!, where: SetWhereUniqueInput!): Set
  updateManySets(data: SetUpdateManyMutationInput!, where: SetWhereInput): BatchPayload!
  upsertSet(where: SetWhereUniqueInput!, create: SetCreateInput!, update: SetUpdateInput!): Set!
  deleteSet(where: SetWhereUniqueInput!): Set
  deleteManySets(where: SetWhereInput): BatchPayload!
  createSubType(data: SubTypeCreateInput!): SubType!
  updateSubType(data: SubTypeUpdateInput!, where: SubTypeWhereUniqueInput!): SubType
  updateManySubTypes(data: SubTypeUpdateManyMutationInput!, where: SubTypeWhereInput): BatchPayload!
  upsertSubType(where: SubTypeWhereUniqueInput!, create: SubTypeCreateInput!, update: SubTypeUpdateInput!): SubType!
  deleteSubType(where: SubTypeWhereUniqueInput!): SubType
  deleteManySubTypes(where: SubTypeWhereInput): BatchPayload!
  createSuperType(data: SuperTypeCreateInput!): SuperType!
  updateSuperType(data: SuperTypeUpdateInput!, where: SuperTypeWhereUniqueInput!): SuperType
  updateManySuperTypes(data: SuperTypeUpdateManyMutationInput!, where: SuperTypeWhereInput): BatchPayload!
  upsertSuperType(where: SuperTypeWhereUniqueInput!, create: SuperTypeCreateInput!, update: SuperTypeUpdateInput!): SuperType!
  deleteSuperType(where: SuperTypeWhereUniqueInput!): SuperType
  deleteManySuperTypes(where: SuperTypeWhereInput): BatchPayload!
  createToken(data: TokenCreateInput!): Token!
  updateToken(data: TokenUpdateInput!, where: TokenWhereUniqueInput!): Token
  updateManyTokens(data: TokenUpdateManyMutationInput!, where: TokenWhereInput): BatchPayload!
  upsertToken(where: TokenWhereUniqueInput!, create: TokenCreateInput!, update: TokenUpdateInput!): Token!
  deleteToken(where: TokenWhereUniqueInput!): Token
  deleteManyTokens(where: TokenWhereInput): BatchPayload!
  createType(data: TypeCreateInput!): Type!
  updateType(data: TypeUpdateInput!, where: TypeWhereUniqueInput!): Type
  updateManyTypes(data: TypeUpdateManyMutationInput!, where: TypeWhereInput): BatchPayload!
  upsertType(where: TypeWhereUniqueInput!, create: TypeCreateInput!, update: TypeUpdateInput!): Type!
  deleteType(where: TypeWhereUniqueInput!): Type
  deleteManyTypes(where: TypeWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Printing {
  id: ID!
  name: String!
}

type PrintingConnection {
  pageInfo: PageInfo!
  edges: [PrintingEdge]!
  aggregate: AggregatePrinting!
}

input PrintingCreateInput {
  id: ID
  name: String!
}

input PrintingCreateManyInput {
  create: [PrintingCreateInput!]
  connect: [PrintingWhereUniqueInput!]
}

type PrintingEdge {
  node: Printing!
  cursor: String!
}

enum PrintingOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type PrintingPreviousValues {
  id: ID!
  name: String!
}

input PrintingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [PrintingScalarWhereInput!]
  OR: [PrintingScalarWhereInput!]
  NOT: [PrintingScalarWhereInput!]
}

type PrintingSubscriptionPayload {
  mutation: MutationType!
  node: Printing
  updatedFields: [String!]
  previousValues: PrintingPreviousValues
}

input PrintingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PrintingWhereInput
  AND: [PrintingSubscriptionWhereInput!]
}

input PrintingUpdateDataInput {
  name: String
}

input PrintingUpdateInput {
  name: String
}

input PrintingUpdateManyDataInput {
  name: String
}

input PrintingUpdateManyInput {
  create: [PrintingCreateInput!]
  update: [PrintingUpdateWithWhereUniqueNestedInput!]
  upsert: [PrintingUpsertWithWhereUniqueNestedInput!]
  delete: [PrintingWhereUniqueInput!]
  connect: [PrintingWhereUniqueInput!]
  set: [PrintingWhereUniqueInput!]
  disconnect: [PrintingWhereUniqueInput!]
  deleteMany: [PrintingScalarWhereInput!]
  updateMany: [PrintingUpdateManyWithWhereNestedInput!]
}

input PrintingUpdateManyMutationInput {
  name: String
}

input PrintingUpdateManyWithWhereNestedInput {
  where: PrintingScalarWhereInput!
  data: PrintingUpdateManyDataInput!
}

input PrintingUpdateWithWhereUniqueNestedInput {
  where: PrintingWhereUniqueInput!
  data: PrintingUpdateDataInput!
}

input PrintingUpsertWithWhereUniqueNestedInput {
  where: PrintingWhereUniqueInput!
  update: PrintingUpdateDataInput!
  create: PrintingCreateInput!
}

input PrintingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [PrintingWhereInput!]
}

input PrintingWhereUniqueInput {
  id: ID
  name: String
}

type Query {
  card(where: CardWhereUniqueInput!): Card
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card]!
  cardsConnection(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CardConnection!
  printing(where: PrintingWhereUniqueInput!): Printing
  printings(where: PrintingWhereInput, orderBy: PrintingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Printing]!
  printingsConnection(where: PrintingWhereInput, orderBy: PrintingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PrintingConnection!
  set(where: SetWhereUniqueInput!): Set
  sets(where: SetWhereInput, orderBy: SetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Set]!
  setsConnection(where: SetWhereInput, orderBy: SetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SetConnection!
  subType(where: SubTypeWhereUniqueInput!): SubType
  subTypes(where: SubTypeWhereInput, orderBy: SubTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubType]!
  subTypesConnection(where: SubTypeWhereInput, orderBy: SubTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubTypeConnection!
  superType(where: SuperTypeWhereUniqueInput!): SuperType
  superTypes(where: SuperTypeWhereInput, orderBy: SuperTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SuperType]!
  superTypesConnection(where: SuperTypeWhereInput, orderBy: SuperTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SuperTypeConnection!
  token(where: TokenWhereUniqueInput!): Token
  tokens(where: TokenWhereInput, orderBy: TokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Token]!
  tokensConnection(where: TokenWhereInput, orderBy: TokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TokenConnection!
  type(where: TypeWhereUniqueInput!): Type
  types(where: TypeWhereInput, orderBy: TypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Type]!
  typesConnection(where: TypeWhereInput, orderBy: TypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TypeConnection!
  node(id: ID!): Node
}

enum Rarity {
  COMMON
  UNCOMMON
  RARE
  MYTHIC
}

type Ruling {
  id: ID!
  date: DateTime!
  text: String!
}

input RulingCreateInput {
  id: ID
  date: DateTime!
  text: String!
}

input RulingCreateManyInput {
  create: [RulingCreateInput!]
}

input RulingRestrictedWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [RulingRestrictedWhereInput!]
}

input RulingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [RulingScalarWhereInput!]
  OR: [RulingScalarWhereInput!]
  NOT: [RulingScalarWhereInput!]
}

input RulingUpdateDataInput {
  date: DateTime
  text: String
}

input RulingUpdateManyDataInput {
  date: DateTime
  text: String
}

input RulingUpdateManyInput {
  create: [RulingCreateInput!]
  update: [RulingUpdateWithWhereUniqueNestedInput!]
  upsert: [RulingUpsertWithWhereUniqueNestedInput!]
  delete: [RulingWhereUniqueInput!]
  deleteMany: [RulingScalarWhereInput!]
  updateMany: [RulingUpdateManyWithWhereNestedInput!]
}

input RulingUpdateManyWithWhereNestedInput {
  where: RulingScalarWhereInput!
  data: RulingUpdateManyDataInput!
}

input RulingUpdateWithWhereUniqueNestedInput {
  where: RulingWhereUniqueInput!
  data: RulingUpdateDataInput!
}

input RulingUpsertWithWhereUniqueNestedInput {
  where: RulingWhereUniqueInput!
  update: RulingUpdateDataInput!
  create: RulingCreateInput!
}

input RulingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [RulingWhereInput!]
}

input RulingWhereUniqueInput {
  id: ID
}

type Set {
  id: ID!
  code: String!
  block: String
  name: String
  releaseDate: DateTime
  type: SetType
  tokens(where: TokenWhereInput, orderBy: TokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Token!]
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card!]
}

type SetConnection {
  pageInfo: PageInfo!
  edges: [SetEdge]!
  aggregate: AggregateSet!
}

input SetCreateInput {
  id: ID
  code: String!
  block: String
  name: String
  releaseDate: DateTime
  type: SetType
  tokens: TokenCreateManyWithoutSetInput
  cards: CardCreateManyWithoutSetInput
}

input SetCreateOneWithoutCardsInput {
  create: SetCreateWithoutCardsInput
  connect: SetWhereUniqueInput
}

input SetCreateOneWithoutTokensInput {
  create: SetCreateWithoutTokensInput
  connect: SetWhereUniqueInput
}

input SetCreateWithoutCardsInput {
  id: ID
  code: String!
  block: String
  name: String
  releaseDate: DateTime
  type: SetType
  tokens: TokenCreateManyWithoutSetInput
}

input SetCreateWithoutTokensInput {
  id: ID
  code: String!
  block: String
  name: String
  releaseDate: DateTime
  type: SetType
  cards: CardCreateManyWithoutSetInput
}

type SetEdge {
  node: Set!
  cursor: String!
}

enum SetOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  block_ASC
  block_DESC
  name_ASC
  name_DESC
  releaseDate_ASC
  releaseDate_DESC
  type_ASC
  type_DESC
}

type SetPreviousValues {
  id: ID!
  code: String!
  block: String
  name: String
  releaseDate: DateTime
  type: SetType
}

type SetSubscriptionPayload {
  mutation: MutationType!
  node: Set
  updatedFields: [String!]
  previousValues: SetPreviousValues
}

input SetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SetWhereInput
  AND: [SetSubscriptionWhereInput!]
}

enum SetType {
  EXPANSION
}

input SetUpdateInput {
  code: String
  block: String
  name: String
  releaseDate: DateTime
  type: SetType
  tokens: TokenUpdateManyWithoutSetInput
  cards: CardUpdateManyWithoutSetInput
}

input SetUpdateManyMutationInput {
  code: String
  block: String
  name: String
  releaseDate: DateTime
  type: SetType
}

input SetUpdateOneRequiredWithoutCardsInput {
  create: SetCreateWithoutCardsInput
  update: SetUpdateWithoutCardsDataInput
  upsert: SetUpsertWithoutCardsInput
  connect: SetWhereUniqueInput
}

input SetUpdateOneRequiredWithoutTokensInput {
  create: SetCreateWithoutTokensInput
  update: SetUpdateWithoutTokensDataInput
  upsert: SetUpsertWithoutTokensInput
  connect: SetWhereUniqueInput
}

input SetUpdateWithoutCardsDataInput {
  code: String
  block: String
  name: String
  releaseDate: DateTime
  type: SetType
  tokens: TokenUpdateManyWithoutSetInput
}

input SetUpdateWithoutTokensDataInput {
  code: String
  block: String
  name: String
  releaseDate: DateTime
  type: SetType
  cards: CardUpdateManyWithoutSetInput
}

input SetUpsertWithoutCardsInput {
  update: SetUpdateWithoutCardsDataInput!
  create: SetCreateWithoutCardsInput!
}

input SetUpsertWithoutTokensInput {
  update: SetUpdateWithoutTokensDataInput!
  create: SetCreateWithoutTokensInput!
}

input SetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  block: String
  block_not: String
  block_in: [String!]
  block_not_in: [String!]
  block_lt: String
  block_lte: String
  block_gt: String
  block_gte: String
  block_contains: String
  block_not_contains: String
  block_starts_with: String
  block_not_starts_with: String
  block_ends_with: String
  block_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  releaseDate: DateTime
  releaseDate_not: DateTime
  releaseDate_in: [DateTime!]
  releaseDate_not_in: [DateTime!]
  releaseDate_lt: DateTime
  releaseDate_lte: DateTime
  releaseDate_gt: DateTime
  releaseDate_gte: DateTime
  type: SetType
  type_not: SetType
  type_in: [SetType!]
  type_not_in: [SetType!]
  tokens_some: TokenWhereInput
  cards_some: CardWhereInput
  AND: [SetWhereInput!]
}

input SetWhereUniqueInput {
  id: ID
  code: String
}

type Subscription {
  card(where: CardSubscriptionWhereInput): CardSubscriptionPayload
  printing(where: PrintingSubscriptionWhereInput): PrintingSubscriptionPayload
  set(where: SetSubscriptionWhereInput): SetSubscriptionPayload
  subType(where: SubTypeSubscriptionWhereInput): SubTypeSubscriptionPayload
  superType(where: SuperTypeSubscriptionWhereInput): SuperTypeSubscriptionPayload
  token(where: TokenSubscriptionWhereInput): TokenSubscriptionPayload
  type(where: TypeSubscriptionWhereInput): TypeSubscriptionPayload
}

type SubType {
  id: ID!
  name: String!
}

type SubTypeConnection {
  pageInfo: PageInfo!
  edges: [SubTypeEdge]!
  aggregate: AggregateSubType!
}

input SubTypeCreateInput {
  id: ID
  name: String!
}

input SubTypeCreateManyInput {
  create: [SubTypeCreateInput!]
  connect: [SubTypeWhereUniqueInput!]
}

type SubTypeEdge {
  node: SubType!
  cursor: String!
}

enum SubTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type SubTypePreviousValues {
  id: ID!
  name: String!
}

input SubTypeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SubTypeScalarWhereInput!]
  OR: [SubTypeScalarWhereInput!]
  NOT: [SubTypeScalarWhereInput!]
}

type SubTypeSubscriptionPayload {
  mutation: MutationType!
  node: SubType
  updatedFields: [String!]
  previousValues: SubTypePreviousValues
}

input SubTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubTypeWhereInput
  AND: [SubTypeSubscriptionWhereInput!]
}

input SubTypeUpdateDataInput {
  name: String
}

input SubTypeUpdateInput {
  name: String
}

input SubTypeUpdateManyDataInput {
  name: String
}

input SubTypeUpdateManyInput {
  create: [SubTypeCreateInput!]
  update: [SubTypeUpdateWithWhereUniqueNestedInput!]
  upsert: [SubTypeUpsertWithWhereUniqueNestedInput!]
  delete: [SubTypeWhereUniqueInput!]
  connect: [SubTypeWhereUniqueInput!]
  set: [SubTypeWhereUniqueInput!]
  disconnect: [SubTypeWhereUniqueInput!]
  deleteMany: [SubTypeScalarWhereInput!]
  updateMany: [SubTypeUpdateManyWithWhereNestedInput!]
}

input SubTypeUpdateManyMutationInput {
  name: String
}

input SubTypeUpdateManyWithWhereNestedInput {
  where: SubTypeScalarWhereInput!
  data: SubTypeUpdateManyDataInput!
}

input SubTypeUpdateWithWhereUniqueNestedInput {
  where: SubTypeWhereUniqueInput!
  data: SubTypeUpdateDataInput!
}

input SubTypeUpsertWithWhereUniqueNestedInput {
  where: SubTypeWhereUniqueInput!
  update: SubTypeUpdateDataInput!
  create: SubTypeCreateInput!
}

input SubTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SubTypeWhereInput!]
}

input SubTypeWhereUniqueInput {
  id: ID
  name: String
}

type SuperType {
  id: ID!
  name: String!
}

type SuperTypeConnection {
  pageInfo: PageInfo!
  edges: [SuperTypeEdge]!
  aggregate: AggregateSuperType!
}

input SuperTypeCreateInput {
  id: ID
  name: String!
}

input SuperTypeCreateManyInput {
  create: [SuperTypeCreateInput!]
  connect: [SuperTypeWhereUniqueInput!]
}

type SuperTypeEdge {
  node: SuperType!
  cursor: String!
}

enum SuperTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type SuperTypePreviousValues {
  id: ID!
  name: String!
}

input SuperTypeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SuperTypeScalarWhereInput!]
  OR: [SuperTypeScalarWhereInput!]
  NOT: [SuperTypeScalarWhereInput!]
}

type SuperTypeSubscriptionPayload {
  mutation: MutationType!
  node: SuperType
  updatedFields: [String!]
  previousValues: SuperTypePreviousValues
}

input SuperTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SuperTypeWhereInput
  AND: [SuperTypeSubscriptionWhereInput!]
}

input SuperTypeUpdateDataInput {
  name: String
}

input SuperTypeUpdateInput {
  name: String
}

input SuperTypeUpdateManyDataInput {
  name: String
}

input SuperTypeUpdateManyInput {
  create: [SuperTypeCreateInput!]
  update: [SuperTypeUpdateWithWhereUniqueNestedInput!]
  upsert: [SuperTypeUpsertWithWhereUniqueNestedInput!]
  delete: [SuperTypeWhereUniqueInput!]
  connect: [SuperTypeWhereUniqueInput!]
  set: [SuperTypeWhereUniqueInput!]
  disconnect: [SuperTypeWhereUniqueInput!]
  deleteMany: [SuperTypeScalarWhereInput!]
  updateMany: [SuperTypeUpdateManyWithWhereNestedInput!]
}

input SuperTypeUpdateManyMutationInput {
  name: String
}

input SuperTypeUpdateManyWithWhereNestedInput {
  where: SuperTypeScalarWhereInput!
  data: SuperTypeUpdateManyDataInput!
}

input SuperTypeUpdateWithWhereUniqueNestedInput {
  where: SuperTypeWhereUniqueInput!
  data: SuperTypeUpdateDataInput!
}

input SuperTypeUpsertWithWhereUniqueNestedInput {
  where: SuperTypeWhereUniqueInput!
  update: SuperTypeUpdateDataInput!
  create: SuperTypeCreateInput!
}

input SuperTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SuperTypeWhereInput!]
}

input SuperTypeWhereUniqueInput {
  id: ID
  name: String
}

type Token {
  id: ID!
  set: Set!
  artist: String!
  borderColor: BorderColor!
  colorIdentities: [Color!]!
  colors: [Color!]!
  layout: Layout!
  name: String!
  number: String!
  power: String
  text: String
  toughness: String
  type: String!
  uuid: String!
  watermark: String
}

type TokenConnection {
  pageInfo: PageInfo!
  edges: [TokenEdge]!
  aggregate: AggregateToken!
}

input TokenCreatecolorIdentitiesInput {
  set: [Color!]
}

input TokenCreatecolorsInput {
  set: [Color!]
}

input TokenCreateInput {
  id: ID
  set: SetCreateOneWithoutTokensInput!
  artist: String!
  borderColor: BorderColor!
  colorIdentities: TokenCreatecolorIdentitiesInput
  colors: TokenCreatecolorsInput
  layout: Layout!
  name: String!
  number: String!
  power: String
  text: String
  toughness: String
  type: String!
  uuid: String!
  watermark: String
}

input TokenCreateManyWithoutSetInput {
  create: [TokenCreateWithoutSetInput!]
  connect: [TokenWhereUniqueInput!]
}

input TokenCreateWithoutSetInput {
  id: ID
  artist: String!
  borderColor: BorderColor!
  colorIdentities: TokenCreatecolorIdentitiesInput
  colors: TokenCreatecolorsInput
  layout: Layout!
  name: String!
  number: String!
  power: String
  text: String
  toughness: String
  type: String!
  uuid: String!
  watermark: String
}

type TokenEdge {
  node: Token!
  cursor: String!
}

enum TokenOrderByInput {
  id_ASC
  id_DESC
  artist_ASC
  artist_DESC
  borderColor_ASC
  borderColor_DESC
  layout_ASC
  layout_DESC
  name_ASC
  name_DESC
  number_ASC
  number_DESC
  power_ASC
  power_DESC
  text_ASC
  text_DESC
  toughness_ASC
  toughness_DESC
  type_ASC
  type_DESC
  uuid_ASC
  uuid_DESC
  watermark_ASC
  watermark_DESC
}

type TokenPreviousValues {
  id: ID!
  artist: String!
  borderColor: BorderColor!
  colorIdentities: [Color!]!
  colors: [Color!]!
  layout: Layout!
  name: String!
  number: String!
  power: String
  text: String
  toughness: String
  type: String!
  uuid: String!
  watermark: String
}

input TokenScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  artist: String
  artist_not: String
  artist_in: [String!]
  artist_not_in: [String!]
  artist_lt: String
  artist_lte: String
  artist_gt: String
  artist_gte: String
  artist_contains: String
  artist_not_contains: String
  artist_starts_with: String
  artist_not_starts_with: String
  artist_ends_with: String
  artist_not_ends_with: String
  borderColor: BorderColor
  borderColor_not: BorderColor
  borderColor_in: [BorderColor!]
  borderColor_not_in: [BorderColor!]
  layout: Layout
  layout_not: Layout
  layout_in: [Layout!]
  layout_not_in: [Layout!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  number: String
  number_not: String
  number_in: [String!]
  number_not_in: [String!]
  number_lt: String
  number_lte: String
  number_gt: String
  number_gte: String
  number_contains: String
  number_not_contains: String
  number_starts_with: String
  number_not_starts_with: String
  number_ends_with: String
  number_not_ends_with: String
  power: String
  power_not: String
  power_in: [String!]
  power_not_in: [String!]
  power_lt: String
  power_lte: String
  power_gt: String
  power_gte: String
  power_contains: String
  power_not_contains: String
  power_starts_with: String
  power_not_starts_with: String
  power_ends_with: String
  power_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  toughness: String
  toughness_not: String
  toughness_in: [String!]
  toughness_not_in: [String!]
  toughness_lt: String
  toughness_lte: String
  toughness_gt: String
  toughness_gte: String
  toughness_contains: String
  toughness_not_contains: String
  toughness_starts_with: String
  toughness_not_starts_with: String
  toughness_ends_with: String
  toughness_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  uuid: String
  uuid_not: String
  uuid_in: [String!]
  uuid_not_in: [String!]
  uuid_lt: String
  uuid_lte: String
  uuid_gt: String
  uuid_gte: String
  uuid_contains: String
  uuid_not_contains: String
  uuid_starts_with: String
  uuid_not_starts_with: String
  uuid_ends_with: String
  uuid_not_ends_with: String
  watermark: String
  watermark_not: String
  watermark_in: [String!]
  watermark_not_in: [String!]
  watermark_lt: String
  watermark_lte: String
  watermark_gt: String
  watermark_gte: String
  watermark_contains: String
  watermark_not_contains: String
  watermark_starts_with: String
  watermark_not_starts_with: String
  watermark_ends_with: String
  watermark_not_ends_with: String
  AND: [TokenScalarWhereInput!]
  OR: [TokenScalarWhereInput!]
  NOT: [TokenScalarWhereInput!]
}

type TokenSubscriptionPayload {
  mutation: MutationType!
  node: Token
  updatedFields: [String!]
  previousValues: TokenPreviousValues
}

input TokenSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TokenWhereInput
  AND: [TokenSubscriptionWhereInput!]
}

input TokenUpdatecolorIdentitiesInput {
  set: [Color!]
}

input TokenUpdatecolorsInput {
  set: [Color!]
}

input TokenUpdateInput {
  set: SetUpdateOneRequiredWithoutTokensInput
  artist: String
  borderColor: BorderColor
  colorIdentities: TokenUpdatecolorIdentitiesInput
  colors: TokenUpdatecolorsInput
  layout: Layout
  name: String
  number: String
  power: String
  text: String
  toughness: String
  type: String
  uuid: String
  watermark: String
}

input TokenUpdateManyDataInput {
  artist: String
  borderColor: BorderColor
  colorIdentities: TokenUpdatecolorIdentitiesInput
  colors: TokenUpdatecolorsInput
  layout: Layout
  name: String
  number: String
  power: String
  text: String
  toughness: String
  type: String
  uuid: String
  watermark: String
}

input TokenUpdateManyMutationInput {
  artist: String
  borderColor: BorderColor
  colorIdentities: TokenUpdatecolorIdentitiesInput
  colors: TokenUpdatecolorsInput
  layout: Layout
  name: String
  number: String
  power: String
  text: String
  toughness: String
  type: String
  uuid: String
  watermark: String
}

input TokenUpdateManyWithoutSetInput {
  create: [TokenCreateWithoutSetInput!]
  delete: [TokenWhereUniqueInput!]
  connect: [TokenWhereUniqueInput!]
  set: [TokenWhereUniqueInput!]
  disconnect: [TokenWhereUniqueInput!]
  update: [TokenUpdateWithWhereUniqueWithoutSetInput!]
  upsert: [TokenUpsertWithWhereUniqueWithoutSetInput!]
  deleteMany: [TokenScalarWhereInput!]
  updateMany: [TokenUpdateManyWithWhereNestedInput!]
}

input TokenUpdateManyWithWhereNestedInput {
  where: TokenScalarWhereInput!
  data: TokenUpdateManyDataInput!
}

input TokenUpdateWithoutSetDataInput {
  artist: String
  borderColor: BorderColor
  colorIdentities: TokenUpdatecolorIdentitiesInput
  colors: TokenUpdatecolorsInput
  layout: Layout
  name: String
  number: String
  power: String
  text: String
  toughness: String
  type: String
  uuid: String
  watermark: String
}

input TokenUpdateWithWhereUniqueWithoutSetInput {
  where: TokenWhereUniqueInput!
  data: TokenUpdateWithoutSetDataInput!
}

input TokenUpsertWithWhereUniqueWithoutSetInput {
  where: TokenWhereUniqueInput!
  update: TokenUpdateWithoutSetDataInput!
  create: TokenCreateWithoutSetInput!
}

input TokenWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  set: SetWhereInput
  artist: String
  artist_not: String
  artist_in: [String!]
  artist_not_in: [String!]
  artist_lt: String
  artist_lte: String
  artist_gt: String
  artist_gte: String
  artist_contains: String
  artist_not_contains: String
  artist_starts_with: String
  artist_not_starts_with: String
  artist_ends_with: String
  artist_not_ends_with: String
  borderColor: BorderColor
  borderColor_not: BorderColor
  borderColor_in: [BorderColor!]
  borderColor_not_in: [BorderColor!]
  layout: Layout
  layout_not: Layout
  layout_in: [Layout!]
  layout_not_in: [Layout!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  number: String
  number_not: String
  number_in: [String!]
  number_not_in: [String!]
  number_lt: String
  number_lte: String
  number_gt: String
  number_gte: String
  number_contains: String
  number_not_contains: String
  number_starts_with: String
  number_not_starts_with: String
  number_ends_with: String
  number_not_ends_with: String
  power: String
  power_not: String
  power_in: [String!]
  power_not_in: [String!]
  power_lt: String
  power_lte: String
  power_gt: String
  power_gte: String
  power_contains: String
  power_not_contains: String
  power_starts_with: String
  power_not_starts_with: String
  power_ends_with: String
  power_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  toughness: String
  toughness_not: String
  toughness_in: [String!]
  toughness_not_in: [String!]
  toughness_lt: String
  toughness_lte: String
  toughness_gt: String
  toughness_gte: String
  toughness_contains: String
  toughness_not_contains: String
  toughness_starts_with: String
  toughness_not_starts_with: String
  toughness_ends_with: String
  toughness_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  uuid: String
  uuid_not: String
  uuid_in: [String!]
  uuid_not_in: [String!]
  uuid_lt: String
  uuid_lte: String
  uuid_gt: String
  uuid_gte: String
  uuid_contains: String
  uuid_not_contains: String
  uuid_starts_with: String
  uuid_not_starts_with: String
  uuid_ends_with: String
  uuid_not_ends_with: String
  watermark: String
  watermark_not: String
  watermark_in: [String!]
  watermark_not_in: [String!]
  watermark_lt: String
  watermark_lte: String
  watermark_gt: String
  watermark_gte: String
  watermark_contains: String
  watermark_not_contains: String
  watermark_starts_with: String
  watermark_not_starts_with: String
  watermark_ends_with: String
  watermark_not_ends_with: String
  AND: [TokenWhereInput!]
}

input TokenWhereUniqueInput {
  id: ID
  uuid: String
}

type Type {
  id: ID!
  name: String!
}

type TypeConnection {
  pageInfo: PageInfo!
  edges: [TypeEdge]!
  aggregate: AggregateType!
}

input TypeCreateInput {
  id: ID
  name: String!
}

input TypeCreateManyInput {
  create: [TypeCreateInput!]
  connect: [TypeWhereUniqueInput!]
}

type TypeEdge {
  node: Type!
  cursor: String!
}

enum TypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type TypePreviousValues {
  id: ID!
  name: String!
}

input TypeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TypeScalarWhereInput!]
  OR: [TypeScalarWhereInput!]
  NOT: [TypeScalarWhereInput!]
}

type TypeSubscriptionPayload {
  mutation: MutationType!
  node: Type
  updatedFields: [String!]
  previousValues: TypePreviousValues
}

input TypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TypeWhereInput
  AND: [TypeSubscriptionWhereInput!]
}

input TypeUpdateDataInput {
  name: String
}

input TypeUpdateInput {
  name: String
}

input TypeUpdateManyDataInput {
  name: String
}

input TypeUpdateManyInput {
  create: [TypeCreateInput!]
  update: [TypeUpdateWithWhereUniqueNestedInput!]
  upsert: [TypeUpsertWithWhereUniqueNestedInput!]
  delete: [TypeWhereUniqueInput!]
  connect: [TypeWhereUniqueInput!]
  set: [TypeWhereUniqueInput!]
  disconnect: [TypeWhereUniqueInput!]
  deleteMany: [TypeScalarWhereInput!]
  updateMany: [TypeUpdateManyWithWhereNestedInput!]
}

input TypeUpdateManyMutationInput {
  name: String
}

input TypeUpdateManyWithWhereNestedInput {
  where: TypeScalarWhereInput!
  data: TypeUpdateManyDataInput!
}

input TypeUpdateWithWhereUniqueNestedInput {
  where: TypeWhereUniqueInput!
  data: TypeUpdateDataInput!
}

input TypeUpsertWithWhereUniqueNestedInput {
  where: TypeWhereUniqueInput!
  update: TypeUpdateDataInput!
  create: TypeCreateInput!
}

input TypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TypeWhereInput!]
}

input TypeWhereUniqueInput {
  id: ID
  name: String
}
`