// Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  card: (where?: CardWhereInput) => Promise<boolean>;
  printing: (where?: PrintingWhereInput) => Promise<boolean>;
  set: (where?: SetWhereInput) => Promise<boolean>;
  subType: (where?: SubTypeWhereInput) => Promise<boolean>;
  superType: (where?: SuperTypeWhereInput) => Promise<boolean>;
  token: (where?: TokenWhereInput) => Promise<boolean>;
  type: (where?: TypeWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  card: (where: CardWhereUniqueInput) => CardPromise;
  cards: (
    args?: {
      where?: CardWhereInput;
      orderBy?: CardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Card>;
  cardsConnection: (
    args?: {
      where?: CardWhereInput;
      orderBy?: CardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CardConnectionPromise;
  printing: (where: PrintingWhereUniqueInput) => PrintingPromise;
  printings: (
    args?: {
      where?: PrintingWhereInput;
      orderBy?: PrintingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Printing>;
  printingsConnection: (
    args?: {
      where?: PrintingWhereInput;
      orderBy?: PrintingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PrintingConnectionPromise;
  set: (where: SetWhereUniqueInput) => SetPromise;
  sets: (
    args?: {
      where?: SetWhereInput;
      orderBy?: SetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Set>;
  setsConnection: (
    args?: {
      where?: SetWhereInput;
      orderBy?: SetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SetConnectionPromise;
  subType: (where: SubTypeWhereUniqueInput) => SubTypePromise;
  subTypes: (
    args?: {
      where?: SubTypeWhereInput;
      orderBy?: SubTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SubType>;
  subTypesConnection: (
    args?: {
      where?: SubTypeWhereInput;
      orderBy?: SubTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SubTypeConnectionPromise;
  superType: (where: SuperTypeWhereUniqueInput) => SuperTypePromise;
  superTypes: (
    args?: {
      where?: SuperTypeWhereInput;
      orderBy?: SuperTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SuperType>;
  superTypesConnection: (
    args?: {
      where?: SuperTypeWhereInput;
      orderBy?: SuperTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SuperTypeConnectionPromise;
  token: (where: TokenWhereUniqueInput) => TokenPromise;
  tokens: (
    args?: {
      where?: TokenWhereInput;
      orderBy?: TokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Token>;
  tokensConnection: (
    args?: {
      where?: TokenWhereInput;
      orderBy?: TokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TokenConnectionPromise;
  type: (where: TypeWhereUniqueInput) => TypePromise;
  types: (
    args?: {
      where?: TypeWhereInput;
      orderBy?: TypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Type>;
  typesConnection: (
    args?: {
      where?: TypeWhereInput;
      orderBy?: TypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TypeConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCard: (data: CardCreateInput) => CardPromise;
  updateCard: (
    args: { data: CardUpdateInput; where: CardWhereUniqueInput }
  ) => CardPromise;
  updateManyCards: (
    args: { data: CardUpdateManyMutationInput; where?: CardWhereInput }
  ) => BatchPayloadPromise;
  upsertCard: (
    args: {
      where: CardWhereUniqueInput;
      create: CardCreateInput;
      update: CardUpdateInput;
    }
  ) => CardPromise;
  deleteCard: (where: CardWhereUniqueInput) => CardPromise;
  deleteManyCards: (where?: CardWhereInput) => BatchPayloadPromise;
  createPrinting: (data: PrintingCreateInput) => PrintingPromise;
  updatePrinting: (
    args: { data: PrintingUpdateInput; where: PrintingWhereUniqueInput }
  ) => PrintingPromise;
  updateManyPrintings: (
    args: { data: PrintingUpdateManyMutationInput; where?: PrintingWhereInput }
  ) => BatchPayloadPromise;
  upsertPrinting: (
    args: {
      where: PrintingWhereUniqueInput;
      create: PrintingCreateInput;
      update: PrintingUpdateInput;
    }
  ) => PrintingPromise;
  deletePrinting: (where: PrintingWhereUniqueInput) => PrintingPromise;
  deleteManyPrintings: (where?: PrintingWhereInput) => BatchPayloadPromise;
  createSet: (data: SetCreateInput) => SetPromise;
  updateSet: (
    args: { data: SetUpdateInput; where: SetWhereUniqueInput }
  ) => SetPromise;
  updateManySets: (
    args: { data: SetUpdateManyMutationInput; where?: SetWhereInput }
  ) => BatchPayloadPromise;
  upsertSet: (
    args: {
      where: SetWhereUniqueInput;
      create: SetCreateInput;
      update: SetUpdateInput;
    }
  ) => SetPromise;
  deleteSet: (where: SetWhereUniqueInput) => SetPromise;
  deleteManySets: (where?: SetWhereInput) => BatchPayloadPromise;
  createSubType: (data: SubTypeCreateInput) => SubTypePromise;
  updateSubType: (
    args: { data: SubTypeUpdateInput; where: SubTypeWhereUniqueInput }
  ) => SubTypePromise;
  updateManySubTypes: (
    args: { data: SubTypeUpdateManyMutationInput; where?: SubTypeWhereInput }
  ) => BatchPayloadPromise;
  upsertSubType: (
    args: {
      where: SubTypeWhereUniqueInput;
      create: SubTypeCreateInput;
      update: SubTypeUpdateInput;
    }
  ) => SubTypePromise;
  deleteSubType: (where: SubTypeWhereUniqueInput) => SubTypePromise;
  deleteManySubTypes: (where?: SubTypeWhereInput) => BatchPayloadPromise;
  createSuperType: (data: SuperTypeCreateInput) => SuperTypePromise;
  updateSuperType: (
    args: { data: SuperTypeUpdateInput; where: SuperTypeWhereUniqueInput }
  ) => SuperTypePromise;
  updateManySuperTypes: (
    args: {
      data: SuperTypeUpdateManyMutationInput;
      where?: SuperTypeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSuperType: (
    args: {
      where: SuperTypeWhereUniqueInput;
      create: SuperTypeCreateInput;
      update: SuperTypeUpdateInput;
    }
  ) => SuperTypePromise;
  deleteSuperType: (where: SuperTypeWhereUniqueInput) => SuperTypePromise;
  deleteManySuperTypes: (where?: SuperTypeWhereInput) => BatchPayloadPromise;
  createToken: (data: TokenCreateInput) => TokenPromise;
  updateToken: (
    args: { data: TokenUpdateInput; where: TokenWhereUniqueInput }
  ) => TokenPromise;
  updateManyTokens: (
    args: { data: TokenUpdateManyMutationInput; where?: TokenWhereInput }
  ) => BatchPayloadPromise;
  upsertToken: (
    args: {
      where: TokenWhereUniqueInput;
      create: TokenCreateInput;
      update: TokenUpdateInput;
    }
  ) => TokenPromise;
  deleteToken: (where: TokenWhereUniqueInput) => TokenPromise;
  deleteManyTokens: (where?: TokenWhereInput) => BatchPayloadPromise;
  createType: (data: TypeCreateInput) => TypePromise;
  updateType: (
    args: { data: TypeUpdateInput; where: TypeWhereUniqueInput }
  ) => TypePromise;
  updateManyTypes: (
    args: { data: TypeUpdateManyMutationInput; where?: TypeWhereInput }
  ) => BatchPayloadPromise;
  upsertType: (
    args: {
      where: TypeWhereUniqueInput;
      create: TypeCreateInput;
      update: TypeUpdateInput;
    }
  ) => TypePromise;
  deleteType: (where: TypeWhereUniqueInput) => TypePromise;
  deleteManyTypes: (where?: TypeWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  card: (
    where?: CardSubscriptionWhereInput
  ) => CardSubscriptionPayloadSubscription;
  printing: (
    where?: PrintingSubscriptionWhereInput
  ) => PrintingSubscriptionPayloadSubscription;
  set: (
    where?: SetSubscriptionWhereInput
  ) => SetSubscriptionPayloadSubscription;
  subType: (
    where?: SubTypeSubscriptionWhereInput
  ) => SubTypeSubscriptionPayloadSubscription;
  superType: (
    where?: SuperTypeSubscriptionWhereInput
  ) => SuperTypeSubscriptionPayloadSubscription;
  token: (
    where?: TokenSubscriptionWhereInput
  ) => TokenSubscriptionPayloadSubscription;
  type: (
    where?: TypeSubscriptionWhereInput
  ) => TypeSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PrintingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type Rarity = "COMMON" | "UNCOMMON" | "RARE" | "MYTHIC";

export type CardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "uuid_ASC"
  | "uuid_DESC"
  | "artist_ASC"
  | "artist_DESC"
  | "layout_ASC"
  | "layout_DESC"
  | "name_ASC"
  | "name_DESC"
  | "number_ASC"
  | "number_DESC"
  | "power_ASC"
  | "power_DESC"
  | "toughness_ASC"
  | "toughness_DESC"
  | "text_ASC"
  | "text_DESC"
  | "type_ASC"
  | "type_DESC"
  | "watermark_ASC"
  | "watermark_DESC"
  | "convertedManaCost_ASC"
  | "convertedManaCost_DESC"
  | "flavorText_ASC"
  | "flavorText_DESC"
  | "manaCost_ASC"
  | "manaCost_DESC"
  | "multiverseId_ASC"
  | "multiverseId_DESC"
  | "rarity_ASC"
  | "rarity_DESC"
  | "legalities_ASC"
  | "legalities_DESC";

export type SetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "block_ASC"
  | "block_DESC"
  | "name_ASC"
  | "name_DESC"
  | "releaseDate_ASC"
  | "releaseDate_DESC"
  | "type_ASC"
  | "type_DESC";

export type BorderColor = "BLACK";

export type TokenOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "artist_ASC"
  | "artist_DESC"
  | "borderColor_ASC"
  | "borderColor_DESC"
  | "layout_ASC"
  | "layout_DESC"
  | "name_ASC"
  | "name_DESC"
  | "number_ASC"
  | "number_DESC"
  | "power_ASC"
  | "power_DESC"
  | "text_ASC"
  | "text_DESC"
  | "toughness_ASC"
  | "toughness_DESC"
  | "type_ASC"
  | "type_DESC"
  | "uuid_ASC"
  | "uuid_DESC"
  | "watermark_ASC"
  | "watermark_DESC";

export type Color = "G" | "R" | "W" | "B" | "U";

export type Layout = "NORMAL";

export type TypeOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type SubTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type SetType = "EXPANSION";

export type SuperTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export interface TokenUpdateManyDataInput {
  artist?: String;
  borderColor?: BorderColor;
  colorIdentities?: TokenUpdatecolorIdentitiesInput;
  colors?: TokenUpdatecolorsInput;
  layout?: Layout;
  name?: String;
  number?: String;
  power?: String;
  text?: String;
  toughness?: String;
  type?: String;
  uuid?: String;
  watermark?: String;
}

export type CardWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  uuid?: String;
}>;

export interface ForeignDataUpdateDataInput {
  multiverseId?: Int;
  flavorText?: String;
  language?: String;
  name?: String;
  text?: String;
  type?: String;
  layout?: Layout;
}

export interface ForeignDataRestrictedWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  multiverseId?: Int;
  multiverseId_not?: Int;
  multiverseId_in?: Int[] | Int;
  multiverseId_not_in?: Int[] | Int;
  multiverseId_lt?: Int;
  multiverseId_lte?: Int;
  multiverseId_gt?: Int;
  multiverseId_gte?: Int;
  flavorText?: String;
  flavorText_not?: String;
  flavorText_in?: String[] | String;
  flavorText_not_in?: String[] | String;
  flavorText_lt?: String;
  flavorText_lte?: String;
  flavorText_gt?: String;
  flavorText_gte?: String;
  flavorText_contains?: String;
  flavorText_not_contains?: String;
  flavorText_starts_with?: String;
  flavorText_not_starts_with?: String;
  flavorText_ends_with?: String;
  flavorText_not_ends_with?: String;
  language?: String;
  language_not?: String;
  language_in?: String[] | String;
  language_not_in?: String[] | String;
  language_lt?: String;
  language_lte?: String;
  language_gt?: String;
  language_gte?: String;
  language_contains?: String;
  language_not_contains?: String;
  language_starts_with?: String;
  language_not_starts_with?: String;
  language_ends_with?: String;
  language_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  layout?: Layout;
  layout_not?: Layout;
  layout_in?: Layout[] | Layout;
  layout_not_in?: Layout[] | Layout;
  AND?: ForeignDataRestrictedWhereInput[] | ForeignDataRestrictedWhereInput;
}

export interface ForeignDataUpsertWithWhereUniqueNestedInput {
  where: ForeignDataWhereUniqueInput;
  update: ForeignDataUpdateDataInput;
  create: ForeignDataCreateInput;
}

export interface RulingRestrictedWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: RulingRestrictedWhereInput[] | RulingRestrictedWhereInput;
}

export interface ForeignDataScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  multiverseId?: Int;
  multiverseId_not?: Int;
  multiverseId_in?: Int[] | Int;
  multiverseId_not_in?: Int[] | Int;
  multiverseId_lt?: Int;
  multiverseId_lte?: Int;
  multiverseId_gt?: Int;
  multiverseId_gte?: Int;
  flavorText?: String;
  flavorText_not?: String;
  flavorText_in?: String[] | String;
  flavorText_not_in?: String[] | String;
  flavorText_lt?: String;
  flavorText_lte?: String;
  flavorText_gt?: String;
  flavorText_gte?: String;
  flavorText_contains?: String;
  flavorText_not_contains?: String;
  flavorText_starts_with?: String;
  flavorText_not_starts_with?: String;
  flavorText_ends_with?: String;
  flavorText_not_ends_with?: String;
  language?: String;
  language_not?: String;
  language_in?: String[] | String;
  language_not_in?: String[] | String;
  language_lt?: String;
  language_lte?: String;
  language_gt?: String;
  language_gte?: String;
  language_contains?: String;
  language_not_contains?: String;
  language_starts_with?: String;
  language_not_starts_with?: String;
  language_ends_with?: String;
  language_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  layout?: Layout;
  layout_not?: Layout;
  layout_in?: Layout[] | Layout;
  layout_not_in?: Layout[] | Layout;
  AND?: ForeignDataScalarWhereInput[] | ForeignDataScalarWhereInput;
  OR?: ForeignDataScalarWhereInput[] | ForeignDataScalarWhereInput;
  NOT?: ForeignDataScalarWhereInput[] | ForeignDataScalarWhereInput;
}

export interface SubTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SubTypeWhereInput[] | SubTypeWhereInput;
}

export interface ForeignDataUpdateManyWithWhereNestedInput {
  where: ForeignDataScalarWhereInput;
  data: ForeignDataUpdateManyDataInput;
}

export interface TypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: TypeWhereInput[] | TypeWhereInput;
}

export interface ForeignDataUpdateManyDataInput {
  multiverseId?: Int;
  flavorText?: String;
  language?: String;
  name?: String;
  text?: String;
  type?: String;
  layout?: Layout;
}

export interface ForeignDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  multiverseId?: Int;
  multiverseId_not?: Int;
  multiverseId_in?: Int[] | Int;
  multiverseId_not_in?: Int[] | Int;
  multiverseId_lt?: Int;
  multiverseId_lte?: Int;
  multiverseId_gt?: Int;
  multiverseId_gte?: Int;
  flavorText?: String;
  flavorText_not?: String;
  flavorText_in?: String[] | String;
  flavorText_not_in?: String[] | String;
  flavorText_lt?: String;
  flavorText_lte?: String;
  flavorText_gt?: String;
  flavorText_gte?: String;
  flavorText_contains?: String;
  flavorText_not_contains?: String;
  flavorText_starts_with?: String;
  flavorText_not_starts_with?: String;
  flavorText_ends_with?: String;
  flavorText_not_ends_with?: String;
  language?: String;
  language_not?: String;
  language_in?: String[] | String;
  language_not_in?: String[] | String;
  language_lt?: String;
  language_lte?: String;
  language_gt?: String;
  language_gte?: String;
  language_contains?: String;
  language_not_contains?: String;
  language_starts_with?: String;
  language_not_starts_with?: String;
  language_ends_with?: String;
  language_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  layout?: Layout;
  layout_not?: Layout;
  layout_in?: Layout[] | Layout;
  layout_not_in?: Layout[] | Layout;
  AND?: ForeignDataWhereInput[] | ForeignDataWhereInput;
}

export interface SuperTypeCreateInput {
  id?: ID_Input;
  name: String;
}

export interface TypeUpdateManyDataInput {
  name?: String;
}

export interface TypeCreateManyInput {
  create?: TypeCreateInput[] | TypeCreateInput;
  connect?: TypeWhereUniqueInput[] | TypeWhereUniqueInput;
}

export interface RulingUpdateManyInput {
  create?: RulingCreateInput[] | RulingCreateInput;
  update?:
    | RulingUpdateWithWhereUniqueNestedInput[]
    | RulingUpdateWithWhereUniqueNestedInput;
  upsert?:
    | RulingUpsertWithWhereUniqueNestedInput[]
    | RulingUpsertWithWhereUniqueNestedInput;
  delete?: RulingWhereUniqueInput[] | RulingWhereUniqueInput;
  deleteMany?: RulingScalarWhereInput[] | RulingScalarWhereInput;
  updateMany?:
    | RulingUpdateManyWithWhereNestedInput[]
    | RulingUpdateManyWithWhereNestedInput;
}

export interface TypeCreateInput {
  id?: ID_Input;
  name: String;
}

export interface TokenSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TokenWhereInput;
  AND?: TokenSubscriptionWhereInput[] | TokenSubscriptionWhereInput;
}

export interface CardUpdateInput {
  set?: SetUpdateOneRequiredWithoutCardsInput;
  uuid?: String;
  artist?: String;
  colorIdentities?: CardUpdatecolorIdentitiesInput;
  colors?: CardUpdatecolorsInput;
  layout?: Layout;
  name?: String;
  number?: String;
  power?: String;
  toughness?: String;
  text?: String;
  type?: String;
  watermark?: String;
  convertedManaCost?: Float;
  flavorText?: String;
  foreignData?: ForeignDataUpdateManyInput;
  manaCost?: String;
  multiverseId?: Int;
  rarity?: Rarity;
  rulings?: RulingUpdateManyInput;
  printings?: PrintingUpdateManyInput;
  subTypes?: SubTypeUpdateManyInput;
  superTypes?: SuperTypeUpdateManyInput;
  types?: TypeUpdateManyInput;
  legalities?: Json;
}

export interface SuperTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SuperTypeWhereInput;
  AND?: SuperTypeSubscriptionWhereInput[] | SuperTypeSubscriptionWhereInput;
}

export interface SetUpdateOneRequiredWithoutCardsInput {
  create?: SetCreateWithoutCardsInput;
  update?: SetUpdateWithoutCardsDataInput;
  upsert?: SetUpsertWithoutCardsInput;
  connect?: SetWhereUniqueInput;
}

export interface SubTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubTypeWhereInput;
  AND?: SubTypeSubscriptionWhereInput[] | SubTypeSubscriptionWhereInput;
}

export interface SetUpdateWithoutCardsDataInput {
  code?: String;
  block?: String;
  name?: String;
  releaseDate?: DateTimeInput;
  type?: SetType;
  tokens?: TokenUpdateManyWithoutSetInput;
}

export interface PrintingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PrintingWhereInput;
  AND?: PrintingSubscriptionWhereInput[] | PrintingSubscriptionWhereInput;
}

export interface TokenUpdateManyWithoutSetInput {
  create?: TokenCreateWithoutSetInput[] | TokenCreateWithoutSetInput;
  delete?: TokenWhereUniqueInput[] | TokenWhereUniqueInput;
  connect?: TokenWhereUniqueInput[] | TokenWhereUniqueInput;
  set?: TokenWhereUniqueInput[] | TokenWhereUniqueInput;
  disconnect?: TokenWhereUniqueInput[] | TokenWhereUniqueInput;
  update?:
    | TokenUpdateWithWhereUniqueWithoutSetInput[]
    | TokenUpdateWithWhereUniqueWithoutSetInput;
  upsert?:
    | TokenUpsertWithWhereUniqueWithoutSetInput[]
    | TokenUpsertWithWhereUniqueWithoutSetInput;
  deleteMany?: TokenScalarWhereInput[] | TokenScalarWhereInput;
  updateMany?:
    | TokenUpdateManyWithWhereNestedInput[]
    | TokenUpdateManyWithWhereNestedInput;
}

export interface TypeUpdateManyMutationInput {
  name?: String;
}

export interface TokenUpdateWithWhereUniqueWithoutSetInput {
  where: TokenWhereUniqueInput;
  data: TokenUpdateWithoutSetDataInput;
}

export interface TokenUpdateManyMutationInput {
  artist?: String;
  borderColor?: BorderColor;
  colorIdentities?: TokenUpdatecolorIdentitiesInput;
  colors?: TokenUpdatecolorsInput;
  layout?: Layout;
  name?: String;
  number?: String;
  power?: String;
  text?: String;
  toughness?: String;
  type?: String;
  uuid?: String;
  watermark?: String;
}

export interface TokenUpdateWithoutSetDataInput {
  artist?: String;
  borderColor?: BorderColor;
  colorIdentities?: TokenUpdatecolorIdentitiesInput;
  colors?: TokenUpdatecolorsInput;
  layout?: Layout;
  name?: String;
  number?: String;
  power?: String;
  text?: String;
  toughness?: String;
  type?: String;
  uuid?: String;
  watermark?: String;
}

export interface SetUpdateWithoutTokensDataInput {
  code?: String;
  block?: String;
  name?: String;
  releaseDate?: DateTimeInput;
  type?: SetType;
  cards?: CardUpdateManyWithoutSetInput;
}

export interface TokenUpdatecolorIdentitiesInput {
  set?: Color[] | Color;
}

export interface TokenUpdateInput {
  set?: SetUpdateOneRequiredWithoutTokensInput;
  artist?: String;
  borderColor?: BorderColor;
  colorIdentities?: TokenUpdatecolorIdentitiesInput;
  colors?: TokenUpdatecolorsInput;
  layout?: Layout;
  name?: String;
  number?: String;
  power?: String;
  text?: String;
  toughness?: String;
  type?: String;
  uuid?: String;
  watermark?: String;
}

export interface TokenUpdatecolorsInput {
  set?: Color[] | Color;
}

export interface SetCreateWithoutTokensInput {
  id?: ID_Input;
  code: String;
  block?: String;
  name?: String;
  releaseDate?: DateTimeInput;
  type?: SetType;
  cards?: CardCreateManyWithoutSetInput;
}

export interface TokenUpsertWithWhereUniqueWithoutSetInput {
  where: TokenWhereUniqueInput;
  update: TokenUpdateWithoutSetDataInput;
  create: TokenCreateWithoutSetInput;
}

export interface TokenCreateInput {
  id?: ID_Input;
  set: SetCreateOneWithoutTokensInput;
  artist: String;
  borderColor: BorderColor;
  colorIdentities?: TokenCreatecolorIdentitiesInput;
  colors?: TokenCreatecolorsInput;
  layout: Layout;
  name: String;
  number: String;
  power?: String;
  text?: String;
  toughness?: String;
  type: String;
  uuid: String;
  watermark?: String;
}

export interface TokenScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  artist?: String;
  artist_not?: String;
  artist_in?: String[] | String;
  artist_not_in?: String[] | String;
  artist_lt?: String;
  artist_lte?: String;
  artist_gt?: String;
  artist_gte?: String;
  artist_contains?: String;
  artist_not_contains?: String;
  artist_starts_with?: String;
  artist_not_starts_with?: String;
  artist_ends_with?: String;
  artist_not_ends_with?: String;
  borderColor?: BorderColor;
  borderColor_not?: BorderColor;
  borderColor_in?: BorderColor[] | BorderColor;
  borderColor_not_in?: BorderColor[] | BorderColor;
  layout?: Layout;
  layout_not?: Layout;
  layout_in?: Layout[] | Layout;
  layout_not_in?: Layout[] | Layout;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  number?: String;
  number_not?: String;
  number_in?: String[] | String;
  number_not_in?: String[] | String;
  number_lt?: String;
  number_lte?: String;
  number_gt?: String;
  number_gte?: String;
  number_contains?: String;
  number_not_contains?: String;
  number_starts_with?: String;
  number_not_starts_with?: String;
  number_ends_with?: String;
  number_not_ends_with?: String;
  power?: String;
  power_not?: String;
  power_in?: String[] | String;
  power_not_in?: String[] | String;
  power_lt?: String;
  power_lte?: String;
  power_gt?: String;
  power_gte?: String;
  power_contains?: String;
  power_not_contains?: String;
  power_starts_with?: String;
  power_not_starts_with?: String;
  power_ends_with?: String;
  power_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  toughness?: String;
  toughness_not?: String;
  toughness_in?: String[] | String;
  toughness_not_in?: String[] | String;
  toughness_lt?: String;
  toughness_lte?: String;
  toughness_gt?: String;
  toughness_gte?: String;
  toughness_contains?: String;
  toughness_not_contains?: String;
  toughness_starts_with?: String;
  toughness_not_starts_with?: String;
  toughness_ends_with?: String;
  toughness_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  watermark?: String;
  watermark_not?: String;
  watermark_in?: String[] | String;
  watermark_not_in?: String[] | String;
  watermark_lt?: String;
  watermark_lte?: String;
  watermark_gt?: String;
  watermark_gte?: String;
  watermark_contains?: String;
  watermark_not_contains?: String;
  watermark_starts_with?: String;
  watermark_not_starts_with?: String;
  watermark_ends_with?: String;
  watermark_not_ends_with?: String;
  AND?: TokenScalarWhereInput[] | TokenScalarWhereInput;
  OR?: TokenScalarWhereInput[] | TokenScalarWhereInput;
  NOT?: TokenScalarWhereInput[] | TokenScalarWhereInput;
}

export interface SuperTypeUpdateManyMutationInput {
  name?: String;
}

export interface TokenUpdateManyWithWhereNestedInput {
  where: TokenScalarWhereInput;
  data: TokenUpdateManyDataInput;
}

export interface SubTypeUpdateManyMutationInput {
  name?: String;
}

export interface PrintingUpdateManyMutationInput {
  name?: String;
}

export type SubTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface SetUpsertWithoutCardsInput {
  update: SetUpdateWithoutCardsDataInput;
  create: SetCreateWithoutCardsInput;
}

export interface CardUpdateManyDataInput {
  uuid?: String;
  artist?: String;
  colorIdentities?: CardUpdatecolorIdentitiesInput;
  colors?: CardUpdatecolorsInput;
  layout?: Layout;
  name?: String;
  number?: String;
  power?: String;
  toughness?: String;
  text?: String;
  type?: String;
  watermark?: String;
  convertedManaCost?: Float;
  flavorText?: String;
  manaCost?: String;
  multiverseId?: Int;
  rarity?: Rarity;
  legalities?: Json;
}

export interface CardUpdatecolorIdentitiesInput {
  set?: Color[] | Color;
}

export type SuperTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface CardUpdatecolorsInput {
  set?: Color[] | Color;
}

export interface CardUpsertWithWhereUniqueWithoutSetInput {
  where: CardWhereUniqueInput;
  update: CardUpdateWithoutSetDataInput;
  create: CardCreateWithoutSetInput;
}

export interface ForeignDataUpdateManyInput {
  create?: ForeignDataCreateInput[] | ForeignDataCreateInput;
  update?:
    | ForeignDataUpdateWithWhereUniqueNestedInput[]
    | ForeignDataUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ForeignDataUpsertWithWhereUniqueNestedInput[]
    | ForeignDataUpsertWithWhereUniqueNestedInput;
  delete?: ForeignDataWhereUniqueInput[] | ForeignDataWhereUniqueInput;
  deleteMany?: ForeignDataScalarWhereInput[] | ForeignDataScalarWhereInput;
  updateMany?:
    | ForeignDataUpdateManyWithWhereNestedInput[]
    | ForeignDataUpdateManyWithWhereNestedInput;
}

export type TokenWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  uuid?: String;
}>;

export interface ForeignDataUpdateWithWhereUniqueNestedInput {
  where: ForeignDataWhereUniqueInput;
  data: ForeignDataUpdateDataInput;
}

export interface CardUpdateManyWithoutSetInput {
  create?: CardCreateWithoutSetInput[] | CardCreateWithoutSetInput;
  delete?: CardWhereUniqueInput[] | CardWhereUniqueInput;
  connect?: CardWhereUniqueInput[] | CardWhereUniqueInput;
  set?: CardWhereUniqueInput[] | CardWhereUniqueInput;
  disconnect?: CardWhereUniqueInput[] | CardWhereUniqueInput;
  update?:
    | CardUpdateWithWhereUniqueWithoutSetInput[]
    | CardUpdateWithWhereUniqueWithoutSetInput;
  upsert?:
    | CardUpsertWithWhereUniqueWithoutSetInput[]
    | CardUpsertWithWhereUniqueWithoutSetInput;
  deleteMany?: CardScalarWhereInput[] | CardScalarWhereInput;
  updateMany?:
    | CardUpdateManyWithWhereNestedInput[]
    | CardUpdateManyWithWhereNestedInput;
}

export type ForeignDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface RulingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: RulingWhereInput[] | RulingWhereInput;
}

export interface CardCreateManyWithoutSetInput {
  create?: CardCreateWithoutSetInput[] | CardCreateWithoutSetInput;
  connect?: CardWhereUniqueInput[] | CardWhereUniqueInput;
}

export interface PrintingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: PrintingWhereInput[] | PrintingWhereInput;
}

export interface SetCreateOneWithoutCardsInput {
  create?: SetCreateWithoutCardsInput;
  connect?: SetWhereUniqueInput;
}

export interface SuperTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SuperTypeWhereInput[] | SuperTypeWhereInput;
}

export interface TokenCreateManyWithoutSetInput {
  create?: TokenCreateWithoutSetInput[] | TokenCreateWithoutSetInput;
  connect?: TokenWhereUniqueInput[] | TokenWhereUniqueInput;
}

export interface PrintingUpdateInput {
  name?: String;
}

export interface TokenCreatecolorIdentitiesInput {
  set?: Color[] | Color;
}

export interface CardUpdateManyMutationInput {
  uuid?: String;
  artist?: String;
  colorIdentities?: CardUpdatecolorIdentitiesInput;
  colors?: CardUpdatecolorsInput;
  layout?: Layout;
  name?: String;
  number?: String;
  power?: String;
  toughness?: String;
  text?: String;
  type?: String;
  watermark?: String;
  convertedManaCost?: Float;
  flavorText?: String;
  manaCost?: String;
  multiverseId?: Int;
  rarity?: Rarity;
  legalities?: Json;
}

export interface CardCreatecolorIdentitiesInput {
  set?: Color[] | Color;
}

export interface CardWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  set?: SetWhereInput;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  artist?: String;
  artist_not?: String;
  artist_in?: String[] | String;
  artist_not_in?: String[] | String;
  artist_lt?: String;
  artist_lte?: String;
  artist_gt?: String;
  artist_gte?: String;
  artist_contains?: String;
  artist_not_contains?: String;
  artist_starts_with?: String;
  artist_not_starts_with?: String;
  artist_ends_with?: String;
  artist_not_ends_with?: String;
  layout?: Layout;
  layout_not?: Layout;
  layout_in?: Layout[] | Layout;
  layout_not_in?: Layout[] | Layout;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  number?: String;
  number_not?: String;
  number_in?: String[] | String;
  number_not_in?: String[] | String;
  number_lt?: String;
  number_lte?: String;
  number_gt?: String;
  number_gte?: String;
  number_contains?: String;
  number_not_contains?: String;
  number_starts_with?: String;
  number_not_starts_with?: String;
  number_ends_with?: String;
  number_not_ends_with?: String;
  power?: String;
  power_not?: String;
  power_in?: String[] | String;
  power_not_in?: String[] | String;
  power_lt?: String;
  power_lte?: String;
  power_gt?: String;
  power_gte?: String;
  power_contains?: String;
  power_not_contains?: String;
  power_starts_with?: String;
  power_not_starts_with?: String;
  power_ends_with?: String;
  power_not_ends_with?: String;
  toughness?: String;
  toughness_not?: String;
  toughness_in?: String[] | String;
  toughness_not_in?: String[] | String;
  toughness_lt?: String;
  toughness_lte?: String;
  toughness_gt?: String;
  toughness_gte?: String;
  toughness_contains?: String;
  toughness_not_contains?: String;
  toughness_starts_with?: String;
  toughness_not_starts_with?: String;
  toughness_ends_with?: String;
  toughness_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  watermark?: String;
  watermark_not?: String;
  watermark_in?: String[] | String;
  watermark_not_in?: String[] | String;
  watermark_lt?: String;
  watermark_lte?: String;
  watermark_gt?: String;
  watermark_gte?: String;
  watermark_contains?: String;
  watermark_not_contains?: String;
  watermark_starts_with?: String;
  watermark_not_starts_with?: String;
  watermark_ends_with?: String;
  watermark_not_ends_with?: String;
  convertedManaCost?: Float;
  convertedManaCost_not?: Float;
  convertedManaCost_in?: Float[] | Float;
  convertedManaCost_not_in?: Float[] | Float;
  convertedManaCost_lt?: Float;
  convertedManaCost_lte?: Float;
  convertedManaCost_gt?: Float;
  convertedManaCost_gte?: Float;
  flavorText?: String;
  flavorText_not?: String;
  flavorText_in?: String[] | String;
  flavorText_not_in?: String[] | String;
  flavorText_lt?: String;
  flavorText_lte?: String;
  flavorText_gt?: String;
  flavorText_gte?: String;
  flavorText_contains?: String;
  flavorText_not_contains?: String;
  flavorText_starts_with?: String;
  flavorText_not_starts_with?: String;
  flavorText_ends_with?: String;
  flavorText_not_ends_with?: String;
  foreignData_some?: ForeignDataWhereInput;
  foreignData_every?: ForeignDataRestrictedWhereInput;
  foreignData_none?: ForeignDataRestrictedWhereInput;
  manaCost?: String;
  manaCost_not?: String;
  manaCost_in?: String[] | String;
  manaCost_not_in?: String[] | String;
  manaCost_lt?: String;
  manaCost_lte?: String;
  manaCost_gt?: String;
  manaCost_gte?: String;
  manaCost_contains?: String;
  manaCost_not_contains?: String;
  manaCost_starts_with?: String;
  manaCost_not_starts_with?: String;
  manaCost_ends_with?: String;
  manaCost_not_ends_with?: String;
  multiverseId?: Int;
  multiverseId_not?: Int;
  multiverseId_in?: Int[] | Int;
  multiverseId_not_in?: Int[] | Int;
  multiverseId_lt?: Int;
  multiverseId_lte?: Int;
  multiverseId_gt?: Int;
  multiverseId_gte?: Int;
  rarity?: Rarity;
  rarity_not?: Rarity;
  rarity_in?: Rarity[] | Rarity;
  rarity_not_in?: Rarity[] | Rarity;
  rulings_some?: RulingWhereInput;
  rulings_every?: RulingRestrictedWhereInput;
  rulings_none?: RulingRestrictedWhereInput;
  printings_some?: PrintingWhereInput;
  subTypes_some?: SubTypeWhereInput;
  superTypes_some?: SuperTypeWhereInput;
  types_some?: TypeWhereInput;
  AND?: CardWhereInput[] | CardWhereInput;
}

export interface ForeignDataCreateManyInput {
  create?: ForeignDataCreateInput[] | ForeignDataCreateInput;
}

export interface RulingUpdateWithWhereUniqueNestedInput {
  where: RulingWhereUniqueInput;
  data: RulingUpdateDataInput;
}

export interface RulingCreateManyInput {
  create?: RulingCreateInput[] | RulingCreateInput;
}

export type RulingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PrintingCreateManyInput {
  create?: PrintingCreateInput[] | PrintingCreateInput;
  connect?: PrintingWhereUniqueInput[] | PrintingWhereUniqueInput;
}

export interface RulingUpdateDataInput {
  date?: DateTimeInput;
  text?: String;
}

export interface SubTypeCreateManyInput {
  create?: SubTypeCreateInput[] | SubTypeCreateInput;
  connect?: SubTypeWhereUniqueInput[] | SubTypeWhereUniqueInput;
}

export interface RulingUpsertWithWhereUniqueNestedInput {
  where: RulingWhereUniqueInput;
  update: RulingUpdateDataInput;
  create: RulingCreateInput;
}

export interface SuperTypeCreateManyInput {
  create?: SuperTypeCreateInput[] | SuperTypeCreateInput;
  connect?: SuperTypeWhereUniqueInput[] | SuperTypeWhereUniqueInput;
}

export interface RulingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: RulingScalarWhereInput[] | RulingScalarWhereInput;
  OR?: RulingScalarWhereInput[] | RulingScalarWhereInput;
  NOT?: RulingScalarWhereInput[] | RulingScalarWhereInput;
}

export interface SetWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  block?: String;
  block_not?: String;
  block_in?: String[] | String;
  block_not_in?: String[] | String;
  block_lt?: String;
  block_lte?: String;
  block_gt?: String;
  block_gte?: String;
  block_contains?: String;
  block_not_contains?: String;
  block_starts_with?: String;
  block_not_starts_with?: String;
  block_ends_with?: String;
  block_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  releaseDate?: DateTimeInput;
  releaseDate_not?: DateTimeInput;
  releaseDate_in?: DateTimeInput[] | DateTimeInput;
  releaseDate_not_in?: DateTimeInput[] | DateTimeInput;
  releaseDate_lt?: DateTimeInput;
  releaseDate_lte?: DateTimeInput;
  releaseDate_gt?: DateTimeInput;
  releaseDate_gte?: DateTimeInput;
  type?: SetType;
  type_not?: SetType;
  type_in?: SetType[] | SetType;
  type_not_in?: SetType[] | SetType;
  tokens_some?: TokenWhereInput;
  cards_some?: CardWhereInput;
  AND?: SetWhereInput[] | SetWhereInput;
}

export interface RulingUpdateManyWithWhereNestedInput {
  where: RulingScalarWhereInput;
  data: RulingUpdateManyDataInput;
}

export interface SetSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SetWhereInput;
  AND?: SetSubscriptionWhereInput[] | SetSubscriptionWhereInput;
}

export interface RulingUpdateManyDataInput {
  date?: DateTimeInput;
  text?: String;
}

export interface TypeUpdateInput {
  name?: String;
}

export interface PrintingUpdateManyInput {
  create?: PrintingCreateInput[] | PrintingCreateInput;
  update?:
    | PrintingUpdateWithWhereUniqueNestedInput[]
    | PrintingUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PrintingUpsertWithWhereUniqueNestedInput[]
    | PrintingUpsertWithWhereUniqueNestedInput;
  delete?: PrintingWhereUniqueInput[] | PrintingWhereUniqueInput;
  connect?: PrintingWhereUniqueInput[] | PrintingWhereUniqueInput;
  set?: PrintingWhereUniqueInput[] | PrintingWhereUniqueInput;
  disconnect?: PrintingWhereUniqueInput[] | PrintingWhereUniqueInput;
  deleteMany?: PrintingScalarWhereInput[] | PrintingScalarWhereInput;
  updateMany?:
    | PrintingUpdateManyWithWhereNestedInput[]
    | PrintingUpdateManyWithWhereNestedInput;
}

export interface SetUpdateOneRequiredWithoutTokensInput {
  create?: SetCreateWithoutTokensInput;
  update?: SetUpdateWithoutTokensDataInput;
  upsert?: SetUpsertWithoutTokensInput;
  connect?: SetWhereUniqueInput;
}

export interface PrintingUpdateWithWhereUniqueNestedInput {
  where: PrintingWhereUniqueInput;
  data: PrintingUpdateDataInput;
}

export interface SetCreateOneWithoutTokensInput {
  create?: SetCreateWithoutTokensInput;
  connect?: SetWhereUniqueInput;
}

export interface PrintingUpdateDataInput {
  name?: String;
}

export interface SuperTypeUpdateInput {
  name?: String;
}

export interface PrintingUpsertWithWhereUniqueNestedInput {
  where: PrintingWhereUniqueInput;
  update: PrintingUpdateDataInput;
  create: PrintingCreateInput;
}

export interface SetUpdateManyMutationInput {
  code?: String;
  block?: String;
  name?: String;
  releaseDate?: DateTimeInput;
  type?: SetType;
}

export interface PrintingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: PrintingScalarWhereInput[] | PrintingScalarWhereInput;
  OR?: PrintingScalarWhereInput[] | PrintingScalarWhereInput;
  NOT?: PrintingScalarWhereInput[] | PrintingScalarWhereInput;
}

export interface CardScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  artist?: String;
  artist_not?: String;
  artist_in?: String[] | String;
  artist_not_in?: String[] | String;
  artist_lt?: String;
  artist_lte?: String;
  artist_gt?: String;
  artist_gte?: String;
  artist_contains?: String;
  artist_not_contains?: String;
  artist_starts_with?: String;
  artist_not_starts_with?: String;
  artist_ends_with?: String;
  artist_not_ends_with?: String;
  layout?: Layout;
  layout_not?: Layout;
  layout_in?: Layout[] | Layout;
  layout_not_in?: Layout[] | Layout;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  number?: String;
  number_not?: String;
  number_in?: String[] | String;
  number_not_in?: String[] | String;
  number_lt?: String;
  number_lte?: String;
  number_gt?: String;
  number_gte?: String;
  number_contains?: String;
  number_not_contains?: String;
  number_starts_with?: String;
  number_not_starts_with?: String;
  number_ends_with?: String;
  number_not_ends_with?: String;
  power?: String;
  power_not?: String;
  power_in?: String[] | String;
  power_not_in?: String[] | String;
  power_lt?: String;
  power_lte?: String;
  power_gt?: String;
  power_gte?: String;
  power_contains?: String;
  power_not_contains?: String;
  power_starts_with?: String;
  power_not_starts_with?: String;
  power_ends_with?: String;
  power_not_ends_with?: String;
  toughness?: String;
  toughness_not?: String;
  toughness_in?: String[] | String;
  toughness_not_in?: String[] | String;
  toughness_lt?: String;
  toughness_lte?: String;
  toughness_gt?: String;
  toughness_gte?: String;
  toughness_contains?: String;
  toughness_not_contains?: String;
  toughness_starts_with?: String;
  toughness_not_starts_with?: String;
  toughness_ends_with?: String;
  toughness_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  watermark?: String;
  watermark_not?: String;
  watermark_in?: String[] | String;
  watermark_not_in?: String[] | String;
  watermark_lt?: String;
  watermark_lte?: String;
  watermark_gt?: String;
  watermark_gte?: String;
  watermark_contains?: String;
  watermark_not_contains?: String;
  watermark_starts_with?: String;
  watermark_not_starts_with?: String;
  watermark_ends_with?: String;
  watermark_not_ends_with?: String;
  convertedManaCost?: Float;
  convertedManaCost_not?: Float;
  convertedManaCost_in?: Float[] | Float;
  convertedManaCost_not_in?: Float[] | Float;
  convertedManaCost_lt?: Float;
  convertedManaCost_lte?: Float;
  convertedManaCost_gt?: Float;
  convertedManaCost_gte?: Float;
  flavorText?: String;
  flavorText_not?: String;
  flavorText_in?: String[] | String;
  flavorText_not_in?: String[] | String;
  flavorText_lt?: String;
  flavorText_lte?: String;
  flavorText_gt?: String;
  flavorText_gte?: String;
  flavorText_contains?: String;
  flavorText_not_contains?: String;
  flavorText_starts_with?: String;
  flavorText_not_starts_with?: String;
  flavorText_ends_with?: String;
  flavorText_not_ends_with?: String;
  manaCost?: String;
  manaCost_not?: String;
  manaCost_in?: String[] | String;
  manaCost_not_in?: String[] | String;
  manaCost_lt?: String;
  manaCost_lte?: String;
  manaCost_gt?: String;
  manaCost_gte?: String;
  manaCost_contains?: String;
  manaCost_not_contains?: String;
  manaCost_starts_with?: String;
  manaCost_not_starts_with?: String;
  manaCost_ends_with?: String;
  manaCost_not_ends_with?: String;
  multiverseId?: Int;
  multiverseId_not?: Int;
  multiverseId_in?: Int[] | Int;
  multiverseId_not_in?: Int[] | Int;
  multiverseId_lt?: Int;
  multiverseId_lte?: Int;
  multiverseId_gt?: Int;
  multiverseId_gte?: Int;
  rarity?: Rarity;
  rarity_not?: Rarity;
  rarity_in?: Rarity[] | Rarity;
  rarity_not_in?: Rarity[] | Rarity;
  AND?: CardScalarWhereInput[] | CardScalarWhereInput;
  OR?: CardScalarWhereInput[] | CardScalarWhereInput;
  NOT?: CardScalarWhereInput[] | CardScalarWhereInput;
}

export interface PrintingUpdateManyWithWhereNestedInput {
  where: PrintingScalarWhereInput;
  data: PrintingUpdateManyDataInput;
}

export interface CardUpdateWithWhereUniqueWithoutSetInput {
  where: CardWhereUniqueInput;
  data: CardUpdateWithoutSetDataInput;
}

export interface PrintingUpdateManyDataInput {
  name?: String;
}

export interface CardCreateWithoutSetInput {
  id?: ID_Input;
  uuid: String;
  artist: String;
  colorIdentities?: CardCreatecolorIdentitiesInput;
  colors?: CardCreatecolorsInput;
  layout: Layout;
  name: String;
  number: String;
  power?: String;
  toughness?: String;
  text?: String;
  type: String;
  watermark?: String;
  convertedManaCost?: Float;
  flavorText?: String;
  foreignData?: ForeignDataCreateManyInput;
  manaCost?: String;
  multiverseId: Int;
  rarity: Rarity;
  rulings?: RulingCreateManyInput;
  printings?: PrintingCreateManyInput;
  subTypes?: SubTypeCreateManyInput;
  superTypes?: SuperTypeCreateManyInput;
  types?: TypeCreateManyInput;
  legalities?: Json;
}

export interface SubTypeUpdateManyInput {
  create?: SubTypeCreateInput[] | SubTypeCreateInput;
  update?:
    | SubTypeUpdateWithWhereUniqueNestedInput[]
    | SubTypeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SubTypeUpsertWithWhereUniqueNestedInput[]
    | SubTypeUpsertWithWhereUniqueNestedInput;
  delete?: SubTypeWhereUniqueInput[] | SubTypeWhereUniqueInput;
  connect?: SubTypeWhereUniqueInput[] | SubTypeWhereUniqueInput;
  set?: SubTypeWhereUniqueInput[] | SubTypeWhereUniqueInput;
  disconnect?: SubTypeWhereUniqueInput[] | SubTypeWhereUniqueInput;
  deleteMany?: SubTypeScalarWhereInput[] | SubTypeScalarWhereInput;
  updateMany?:
    | SubTypeUpdateManyWithWhereNestedInput[]
    | SubTypeUpdateManyWithWhereNestedInput;
}

export interface CardCreateInput {
  id?: ID_Input;
  set: SetCreateOneWithoutCardsInput;
  uuid: String;
  artist: String;
  colorIdentities?: CardCreatecolorIdentitiesInput;
  colors?: CardCreatecolorsInput;
  layout: Layout;
  name: String;
  number: String;
  power?: String;
  toughness?: String;
  text?: String;
  type: String;
  watermark?: String;
  convertedManaCost?: Float;
  flavorText?: String;
  foreignData?: ForeignDataCreateManyInput;
  manaCost?: String;
  multiverseId: Int;
  rarity: Rarity;
  rulings?: RulingCreateManyInput;
  printings?: PrintingCreateManyInput;
  subTypes?: SubTypeCreateManyInput;
  superTypes?: SuperTypeCreateManyInput;
  types?: TypeCreateManyInput;
  legalities?: Json;
}

export interface SubTypeUpdateWithWhereUniqueNestedInput {
  where: SubTypeWhereUniqueInput;
  data: SubTypeUpdateDataInput;
}

export interface TokenCreateWithoutSetInput {
  id?: ID_Input;
  artist: String;
  borderColor: BorderColor;
  colorIdentities?: TokenCreatecolorIdentitiesInput;
  colors?: TokenCreatecolorsInput;
  layout: Layout;
  name: String;
  number: String;
  power?: String;
  text?: String;
  toughness?: String;
  type: String;
  uuid: String;
  watermark?: String;
}

export interface SubTypeUpdateDataInput {
  name?: String;
}

export interface CardCreatecolorsInput {
  set?: Color[] | Color;
}

export interface SubTypeUpsertWithWhereUniqueNestedInput {
  where: SubTypeWhereUniqueInput;
  update: SubTypeUpdateDataInput;
  create: SubTypeCreateInput;
}

export interface RulingCreateInput {
  id?: ID_Input;
  date: DateTimeInput;
  text: String;
}

export interface SubTypeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SubTypeScalarWhereInput[] | SubTypeScalarWhereInput;
  OR?: SubTypeScalarWhereInput[] | SubTypeScalarWhereInput;
  NOT?: SubTypeScalarWhereInput[] | SubTypeScalarWhereInput;
}

export interface SubTypeCreateInput {
  id?: ID_Input;
  name: String;
}

export interface SubTypeUpdateManyWithWhereNestedInput {
  where: SubTypeScalarWhereInput;
  data: SubTypeUpdateManyDataInput;
}

export interface TokenWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  set?: SetWhereInput;
  artist?: String;
  artist_not?: String;
  artist_in?: String[] | String;
  artist_not_in?: String[] | String;
  artist_lt?: String;
  artist_lte?: String;
  artist_gt?: String;
  artist_gte?: String;
  artist_contains?: String;
  artist_not_contains?: String;
  artist_starts_with?: String;
  artist_not_starts_with?: String;
  artist_ends_with?: String;
  artist_not_ends_with?: String;
  borderColor?: BorderColor;
  borderColor_not?: BorderColor;
  borderColor_in?: BorderColor[] | BorderColor;
  borderColor_not_in?: BorderColor[] | BorderColor;
  layout?: Layout;
  layout_not?: Layout;
  layout_in?: Layout[] | Layout;
  layout_not_in?: Layout[] | Layout;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  number?: String;
  number_not?: String;
  number_in?: String[] | String;
  number_not_in?: String[] | String;
  number_lt?: String;
  number_lte?: String;
  number_gt?: String;
  number_gte?: String;
  number_contains?: String;
  number_not_contains?: String;
  number_starts_with?: String;
  number_not_starts_with?: String;
  number_ends_with?: String;
  number_not_ends_with?: String;
  power?: String;
  power_not?: String;
  power_in?: String[] | String;
  power_not_in?: String[] | String;
  power_lt?: String;
  power_lte?: String;
  power_gt?: String;
  power_gte?: String;
  power_contains?: String;
  power_not_contains?: String;
  power_starts_with?: String;
  power_not_starts_with?: String;
  power_ends_with?: String;
  power_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  toughness?: String;
  toughness_not?: String;
  toughness_in?: String[] | String;
  toughness_not_in?: String[] | String;
  toughness_lt?: String;
  toughness_lte?: String;
  toughness_gt?: String;
  toughness_gte?: String;
  toughness_contains?: String;
  toughness_not_contains?: String;
  toughness_starts_with?: String;
  toughness_not_starts_with?: String;
  toughness_ends_with?: String;
  toughness_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  uuid?: String;
  uuid_not?: String;
  uuid_in?: String[] | String;
  uuid_not_in?: String[] | String;
  uuid_lt?: String;
  uuid_lte?: String;
  uuid_gt?: String;
  uuid_gte?: String;
  uuid_contains?: String;
  uuid_not_contains?: String;
  uuid_starts_with?: String;
  uuid_not_starts_with?: String;
  uuid_ends_with?: String;
  uuid_not_ends_with?: String;
  watermark?: String;
  watermark_not?: String;
  watermark_in?: String[] | String;
  watermark_not_in?: String[] | String;
  watermark_lt?: String;
  watermark_lte?: String;
  watermark_gt?: String;
  watermark_gte?: String;
  watermark_contains?: String;
  watermark_not_contains?: String;
  watermark_starts_with?: String;
  watermark_not_starts_with?: String;
  watermark_ends_with?: String;
  watermark_not_ends_with?: String;
  AND?: TokenWhereInput[] | TokenWhereInput;
}

export interface SubTypeUpdateManyDataInput {
  name?: String;
}

export interface SetUpsertWithoutTokensInput {
  update: SetUpdateWithoutTokensDataInput;
  create: SetCreateWithoutTokensInput;
}

export interface SuperTypeUpdateManyInput {
  create?: SuperTypeCreateInput[] | SuperTypeCreateInput;
  update?:
    | SuperTypeUpdateWithWhereUniqueNestedInput[]
    | SuperTypeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SuperTypeUpsertWithWhereUniqueNestedInput[]
    | SuperTypeUpsertWithWhereUniqueNestedInput;
  delete?: SuperTypeWhereUniqueInput[] | SuperTypeWhereUniqueInput;
  connect?: SuperTypeWhereUniqueInput[] | SuperTypeWhereUniqueInput;
  set?: SuperTypeWhereUniqueInput[] | SuperTypeWhereUniqueInput;
  disconnect?: SuperTypeWhereUniqueInput[] | SuperTypeWhereUniqueInput;
  deleteMany?: SuperTypeScalarWhereInput[] | SuperTypeScalarWhereInput;
  updateMany?:
    | SuperTypeUpdateManyWithWhereNestedInput[]
    | SuperTypeUpdateManyWithWhereNestedInput;
}

export type SetWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface SuperTypeUpdateWithWhereUniqueNestedInput {
  where: SuperTypeWhereUniqueInput;
  data: SuperTypeUpdateDataInput;
}

export interface CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput;
  data: CardUpdateManyDataInput;
}

export interface SuperTypeUpdateDataInput {
  name?: String;
}

export interface SetUpdateInput {
  code?: String;
  block?: String;
  name?: String;
  releaseDate?: DateTimeInput;
  type?: SetType;
  tokens?: TokenUpdateManyWithoutSetInput;
  cards?: CardUpdateManyWithoutSetInput;
}

export interface SuperTypeUpsertWithWhereUniqueNestedInput {
  where: SuperTypeWhereUniqueInput;
  update: SuperTypeUpdateDataInput;
  create: SuperTypeCreateInput;
}

export interface SetCreateWithoutCardsInput {
  id?: ID_Input;
  code: String;
  block?: String;
  name?: String;
  releaseDate?: DateTimeInput;
  type?: SetType;
  tokens?: TokenCreateManyWithoutSetInput;
}

export interface SuperTypeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SuperTypeScalarWhereInput[] | SuperTypeScalarWhereInput;
  OR?: SuperTypeScalarWhereInput[] | SuperTypeScalarWhereInput;
  NOT?: SuperTypeScalarWhereInput[] | SuperTypeScalarWhereInput;
}

export interface ForeignDataCreateInput {
  id?: ID_Input;
  multiverseId: Int;
  flavorText?: String;
  language: String;
  name: String;
  text?: String;
  type?: String;
  layout?: Layout;
}

export interface SuperTypeUpdateManyWithWhereNestedInput {
  where: SuperTypeScalarWhereInput;
  data: SuperTypeUpdateManyDataInput;
}

export interface TypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TypeWhereInput;
  AND?: TypeSubscriptionWhereInput[] | TypeSubscriptionWhereInput;
}

export interface SuperTypeUpdateManyDataInput {
  name?: String;
}

export type PrintingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface TypeUpdateManyInput {
  create?: TypeCreateInput[] | TypeCreateInput;
  update?:
    | TypeUpdateWithWhereUniqueNestedInput[]
    | TypeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TypeUpsertWithWhereUniqueNestedInput[]
    | TypeUpsertWithWhereUniqueNestedInput;
  delete?: TypeWhereUniqueInput[] | TypeWhereUniqueInput;
  connect?: TypeWhereUniqueInput[] | TypeWhereUniqueInput;
  set?: TypeWhereUniqueInput[] | TypeWhereUniqueInput;
  disconnect?: TypeWhereUniqueInput[] | TypeWhereUniqueInput;
  deleteMany?: TypeScalarWhereInput[] | TypeScalarWhereInput;
  updateMany?:
    | TypeUpdateManyWithWhereNestedInput[]
    | TypeUpdateManyWithWhereNestedInput;
}

export interface CardUpdateWithoutSetDataInput {
  uuid?: String;
  artist?: String;
  colorIdentities?: CardUpdatecolorIdentitiesInput;
  colors?: CardUpdatecolorsInput;
  layout?: Layout;
  name?: String;
  number?: String;
  power?: String;
  toughness?: String;
  text?: String;
  type?: String;
  watermark?: String;
  convertedManaCost?: Float;
  flavorText?: String;
  foreignData?: ForeignDataUpdateManyInput;
  manaCost?: String;
  multiverseId?: Int;
  rarity?: Rarity;
  rulings?: RulingUpdateManyInput;
  printings?: PrintingUpdateManyInput;
  subTypes?: SubTypeUpdateManyInput;
  superTypes?: SuperTypeUpdateManyInput;
  types?: TypeUpdateManyInput;
  legalities?: Json;
}

export interface TypeUpdateWithWhereUniqueNestedInput {
  where: TypeWhereUniqueInput;
  data: TypeUpdateDataInput;
}

export interface TokenCreatecolorsInput {
  set?: Color[] | Color;
}

export interface TypeUpdateManyWithWhereNestedInput {
  where: TypeScalarWhereInput;
  data: TypeUpdateManyDataInput;
}

export interface TypeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: TypeScalarWhereInput[] | TypeScalarWhereInput;
  OR?: TypeScalarWhereInput[] | TypeScalarWhereInput;
  NOT?: TypeScalarWhereInput[] | TypeScalarWhereInput;
}

export interface TypeUpsertWithWhereUniqueNestedInput {
  where: TypeWhereUniqueInput;
  update: TypeUpdateDataInput;
  create: TypeCreateInput;
}

export interface TypeUpdateDataInput {
  name?: String;
}

export interface PrintingCreateInput {
  id?: ID_Input;
  name: String;
}

export interface SetCreateInput {
  id?: ID_Input;
  code: String;
  block?: String;
  name?: String;
  releaseDate?: DateTimeInput;
  type?: SetType;
  tokens?: TokenCreateManyWithoutSetInput;
  cards?: CardCreateManyWithoutSetInput;
}

export interface SubTypeUpdateInput {
  name?: String;
}

export interface CardSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CardWhereInput;
  AND?: CardSubscriptionWhereInput[] | CardSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface TypePreviousValues {
  id: ID_Output;
  name: String;
}

export interface TypePreviousValuesPromise
  extends Promise<TypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TypePreviousValuesSubscription
  extends Promise<AsyncIterator<TypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface PrintingConnection {
  pageInfo: PageInfo;
  edges: PrintingEdge[];
}

export interface PrintingConnectionPromise
  extends Promise<PrintingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PrintingEdge>>() => T;
  aggregate: <T = AggregatePrintingPromise>() => T;
}

export interface PrintingConnectionSubscription
  extends Promise<AsyncIterator<PrintingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PrintingEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePrintingSubscription>() => T;
}

export interface SuperTypeSubscriptionPayload {
  mutation: MutationType;
  node: SuperType;
  updatedFields: String[];
  previousValues: SuperTypePreviousValues;
}

export interface SuperTypeSubscriptionPayloadPromise
  extends Promise<SuperTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SuperTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SuperTypePreviousValuesPromise>() => T;
}

export interface SuperTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SuperTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SuperTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SuperTypePreviousValuesSubscription>() => T;
}

export interface AggregateCard {
  count: Int;
}

export interface AggregateCardPromise
  extends Promise<AggregateCard>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCardSubscription
  extends Promise<AsyncIterator<AggregateCard>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Token {
  id: ID_Output;
  artist: String;
  borderColor: BorderColor;
  colorIdentities: Color[];
  colors: Color[];
  layout: Layout;
  name: String;
  number: String;
  power?: String;
  text?: String;
  toughness?: String;
  type: String;
  uuid: String;
  watermark?: String;
}

export interface TokenPromise extends Promise<Token>, Fragmentable {
  id: () => Promise<ID_Output>;
  set: <T = SetPromise>() => T;
  artist: () => Promise<String>;
  borderColor: () => Promise<BorderColor>;
  colorIdentities: () => Promise<Color[]>;
  colors: () => Promise<Color[]>;
  layout: () => Promise<Layout>;
  name: () => Promise<String>;
  number: () => Promise<String>;
  power: () => Promise<String>;
  text: () => Promise<String>;
  toughness: () => Promise<String>;
  type: () => Promise<String>;
  uuid: () => Promise<String>;
  watermark: () => Promise<String>;
}

export interface TokenSubscription
  extends Promise<AsyncIterator<Token>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  set: <T = SetSubscription>() => T;
  artist: () => Promise<AsyncIterator<String>>;
  borderColor: () => Promise<AsyncIterator<BorderColor>>;
  colorIdentities: () => Promise<AsyncIterator<Color[]>>;
  colors: () => Promise<AsyncIterator<Color[]>>;
  layout: () => Promise<AsyncIterator<Layout>>;
  name: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  power: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  toughness: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  watermark: () => Promise<AsyncIterator<String>>;
}

export interface CardEdge {
  node: Card;
  cursor: String;
}

export interface CardEdgePromise extends Promise<CardEdge>, Fragmentable {
  node: <T = CardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CardEdgeSubscription
  extends Promise<AsyncIterator<CardEdge>>,
    Fragmentable {
  node: <T = CardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ForeignData {
  id: ID_Output;
  multiverseId: Int;
  flavorText?: String;
  language: String;
  name: String;
  text?: String;
  type?: String;
  layout?: Layout;
}

export interface ForeignDataPromise extends Promise<ForeignData>, Fragmentable {
  id: () => Promise<ID_Output>;
  multiverseId: () => Promise<Int>;
  flavorText: () => Promise<String>;
  language: () => Promise<String>;
  name: () => Promise<String>;
  text: () => Promise<String>;
  type: () => Promise<String>;
  layout: () => Promise<Layout>;
}

export interface ForeignDataSubscription
  extends Promise<AsyncIterator<ForeignData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  multiverseId: () => Promise<AsyncIterator<Int>>;
  flavorText: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  layout: () => Promise<AsyncIterator<Layout>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateType {
  count: Int;
}

export interface AggregateTypePromise
  extends Promise<AggregateType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTypeSubscription
  extends Promise<AsyncIterator<AggregateType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface TypeConnection {
  pageInfo: PageInfo;
  edges: TypeEdge[];
}

export interface TypeConnectionPromise
  extends Promise<TypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TypeEdge>>() => T;
  aggregate: <T = AggregateTypePromise>() => T;
}

export interface TypeConnectionSubscription
  extends Promise<AsyncIterator<TypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTypeSubscription>() => T;
}

export interface CardConnection {
  pageInfo: PageInfo;
  edges: CardEdge[];
}

export interface CardConnectionPromise
  extends Promise<CardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CardEdge>>() => T;
  aggregate: <T = AggregateCardPromise>() => T;
}

export interface CardConnectionSubscription
  extends Promise<AsyncIterator<CardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCardSubscription>() => T;
}

export interface TokenEdge {
  node: Token;
  cursor: String;
}

export interface TokenEdgePromise extends Promise<TokenEdge>, Fragmentable {
  node: <T = TokenPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TokenEdgeSubscription
  extends Promise<AsyncIterator<TokenEdge>>,
    Fragmentable {
  node: <T = TokenSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TokenSubscriptionPayload {
  mutation: MutationType;
  node: Token;
  updatedFields: String[];
  previousValues: TokenPreviousValues;
}

export interface TokenSubscriptionPayloadPromise
  extends Promise<TokenSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TokenPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TokenPreviousValuesPromise>() => T;
}

export interface TokenSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TokenSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TokenSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TokenPreviousValuesSubscription>() => T;
}

export interface AggregateSuperType {
  count: Int;
}

export interface AggregateSuperTypePromise
  extends Promise<AggregateSuperType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSuperTypeSubscription
  extends Promise<AsyncIterator<AggregateSuperType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Type {
  id: ID_Output;
  name: String;
}

export interface TypePromise extends Promise<Type>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TypeSubscription
  extends Promise<AsyncIterator<Type>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SuperTypeConnection {
  pageInfo: PageInfo;
  edges: SuperTypeEdge[];
}

export interface SuperTypeConnectionPromise
  extends Promise<SuperTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SuperTypeEdge>>() => T;
  aggregate: <T = AggregateSuperTypePromise>() => T;
}

export interface SuperTypeConnectionSubscription
  extends Promise<AsyncIterator<SuperTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SuperTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSuperTypeSubscription>() => T;
}

export interface Set {
  id: ID_Output;
  code: String;
  block?: String;
  name?: String;
  releaseDate?: DateTimeOutput;
  type?: SetType;
}

export interface SetPromise extends Promise<Set>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  block: () => Promise<String>;
  name: () => Promise<String>;
  releaseDate: () => Promise<DateTimeOutput>;
  type: () => Promise<SetType>;
  tokens: <T = FragmentableArray<Token>>(
    args?: {
      where?: TokenWhereInput;
      orderBy?: TokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cards: <T = FragmentableArray<Card>>(
    args?: {
      where?: CardWhereInput;
      orderBy?: CardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SetSubscription
  extends Promise<AsyncIterator<Set>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  block: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  releaseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<SetType>>;
  tokens: <T = Promise<AsyncIterator<TokenSubscription>>>(
    args?: {
      where?: TokenWhereInput;
      orderBy?: TokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cards: <T = Promise<AsyncIterator<CardSubscription>>>(
    args?: {
      where?: CardWhereInput;
      orderBy?: CardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SubTypeEdge {
  node: SubType;
  cursor: String;
}

export interface SubTypeEdgePromise extends Promise<SubTypeEdge>, Fragmentable {
  node: <T = SubTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubTypeEdgeSubscription
  extends Promise<AsyncIterator<SubTypeEdge>>,
    Fragmentable {
  node: <T = SubTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Ruling {
  id: ID_Output;
  date: DateTimeOutput;
  text: String;
}

export interface RulingPromise extends Promise<Ruling>, Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
}

export interface RulingSubscription
  extends Promise<AsyncIterator<Ruling>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSet {
  count: Int;
}

export interface AggregateSetPromise
  extends Promise<AggregateSet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSetSubscription
  extends Promise<AsyncIterator<AggregateSet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CardSubscriptionPayload {
  mutation: MutationType;
  node: Card;
  updatedFields: String[];
  previousValues: CardPreviousValues;
}

export interface CardSubscriptionPayloadPromise
  extends Promise<CardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CardPreviousValuesPromise>() => T;
}

export interface CardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CardPreviousValuesSubscription>() => T;
}

export interface SetConnection {
  pageInfo: PageInfo;
  edges: SetEdge[];
}

export interface SetConnectionPromise
  extends Promise<SetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SetEdge>>() => T;
  aggregate: <T = AggregateSetPromise>() => T;
}

export interface SetConnectionSubscription
  extends Promise<AsyncIterator<SetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSetSubscription>() => T;
}

export interface CardPreviousValues {
  id: ID_Output;
  uuid: String;
  artist: String;
  colorIdentities: Color[];
  colors: Color[];
  layout: Layout;
  name: String;
  number: String;
  power?: String;
  toughness?: String;
  text?: String;
  type: String;
  watermark?: String;
  convertedManaCost: Float;
  flavorText?: String;
  manaCost: String;
  multiverseId: Int;
  rarity: Rarity;
  legalities?: Json;
}

export interface CardPreviousValuesPromise
  extends Promise<CardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uuid: () => Promise<String>;
  artist: () => Promise<String>;
  colorIdentities: () => Promise<Color[]>;
  colors: () => Promise<Color[]>;
  layout: () => Promise<Layout>;
  name: () => Promise<String>;
  number: () => Promise<String>;
  power: () => Promise<String>;
  toughness: () => Promise<String>;
  text: () => Promise<String>;
  type: () => Promise<String>;
  watermark: () => Promise<String>;
  convertedManaCost: () => Promise<Float>;
  flavorText: () => Promise<String>;
  manaCost: () => Promise<String>;
  multiverseId: () => Promise<Int>;
  rarity: () => Promise<Rarity>;
  legalities: () => Promise<Json>;
}

export interface CardPreviousValuesSubscription
  extends Promise<AsyncIterator<CardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uuid: () => Promise<AsyncIterator<String>>;
  artist: () => Promise<AsyncIterator<String>>;
  colorIdentities: () => Promise<AsyncIterator<Color[]>>;
  colors: () => Promise<AsyncIterator<Color[]>>;
  layout: () => Promise<AsyncIterator<Layout>>;
  name: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  power: () => Promise<AsyncIterator<String>>;
  toughness: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  watermark: () => Promise<AsyncIterator<String>>;
  convertedManaCost: () => Promise<AsyncIterator<Float>>;
  flavorText: () => Promise<AsyncIterator<String>>;
  manaCost: () => Promise<AsyncIterator<String>>;
  multiverseId: () => Promise<AsyncIterator<Int>>;
  rarity: () => Promise<AsyncIterator<Rarity>>;
  legalities: () => Promise<AsyncIterator<Json>>;
}

export interface AggregatePrinting {
  count: Int;
}

export interface AggregatePrintingPromise
  extends Promise<AggregatePrinting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePrintingSubscription
  extends Promise<AsyncIterator<AggregatePrinting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SuperType {
  id: ID_Output;
  name: String;
}

export interface SuperTypePromise extends Promise<SuperType>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SuperTypeSubscription
  extends Promise<AsyncIterator<SuperType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface TypeSubscriptionPayload {
  mutation: MutationType;
  node: Type;
  updatedFields: String[];
  previousValues: TypePreviousValues;
}

export interface TypeSubscriptionPayloadPromise
  extends Promise<TypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TypePreviousValuesPromise>() => T;
}

export interface TypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TypePreviousValuesSubscription>() => T;
}

export interface PrintingSubscriptionPayload {
  mutation: MutationType;
  node: Printing;
  updatedFields: String[];
  previousValues: PrintingPreviousValues;
}

export interface PrintingSubscriptionPayloadPromise
  extends Promise<PrintingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PrintingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PrintingPreviousValuesPromise>() => T;
}

export interface PrintingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PrintingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PrintingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PrintingPreviousValuesSubscription>() => T;
}

export interface TypeEdge {
  node: Type;
  cursor: String;
}

export interface TypeEdgePromise extends Promise<TypeEdge>, Fragmentable {
  node: <T = TypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TypeEdgeSubscription
  extends Promise<AsyncIterator<TypeEdge>>,
    Fragmentable {
  node: <T = TypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PrintingPreviousValues {
  id: ID_Output;
  name: String;
}

export interface PrintingPreviousValuesPromise
  extends Promise<PrintingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface PrintingPreviousValuesSubscription
  extends Promise<AsyncIterator<PrintingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface TokenConnection {
  pageInfo: PageInfo;
  edges: TokenEdge[];
}

export interface TokenConnectionPromise
  extends Promise<TokenConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TokenEdge>>() => T;
  aggregate: <T = AggregateTokenPromise>() => T;
}

export interface TokenConnectionSubscription
  extends Promise<AsyncIterator<TokenConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TokenEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTokenSubscription>() => T;
}

export interface SuperTypePreviousValues {
  id: ID_Output;
  name: String;
}

export interface SuperTypePreviousValuesPromise
  extends Promise<SuperTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SuperTypePreviousValuesSubscription
  extends Promise<AsyncIterator<SuperTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubType {
  count: Int;
}

export interface AggregateSubTypePromise
  extends Promise<AggregateSubType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubTypeSubscription
  extends Promise<AsyncIterator<AggregateSubType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SetSubscriptionPayload {
  mutation: MutationType;
  node: Set;
  updatedFields: String[];
  previousValues: SetPreviousValues;
}

export interface SetSubscriptionPayloadPromise
  extends Promise<SetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SetPreviousValuesPromise>() => T;
}

export interface SetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SetPreviousValuesSubscription>() => T;
}

export interface SetEdge {
  node: Set;
  cursor: String;
}

export interface SetEdgePromise extends Promise<SetEdge>, Fragmentable {
  node: <T = SetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SetEdgeSubscription
  extends Promise<AsyncIterator<SetEdge>>,
    Fragmentable {
  node: <T = SetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SetPreviousValues {
  id: ID_Output;
  code: String;
  block?: String;
  name?: String;
  releaseDate?: DateTimeOutput;
  type?: SetType;
}

export interface SetPreviousValuesPromise
  extends Promise<SetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  block: () => Promise<String>;
  name: () => Promise<String>;
  releaseDate: () => Promise<DateTimeOutput>;
  type: () => Promise<SetType>;
}

export interface SetPreviousValuesSubscription
  extends Promise<AsyncIterator<SetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  block: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  releaseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<SetType>>;
}

export interface PrintingEdge {
  node: Printing;
  cursor: String;
}

export interface PrintingEdgePromise
  extends Promise<PrintingEdge>,
    Fragmentable {
  node: <T = PrintingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PrintingEdgeSubscription
  extends Promise<AsyncIterator<PrintingEdge>>,
    Fragmentable {
  node: <T = PrintingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateToken {
  count: Int;
}

export interface AggregateTokenPromise
  extends Promise<AggregateToken>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTokenSubscription
  extends Promise<AsyncIterator<AggregateToken>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Printing {
  id: ID_Output;
  name: String;
}

export interface PrintingPromise extends Promise<Printing>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface PrintingSubscription
  extends Promise<AsyncIterator<Printing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SubTypePreviousValues {
  id: ID_Output;
  name: String;
}

export interface SubTypePreviousValuesPromise
  extends Promise<SubTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SubTypePreviousValuesSubscription
  extends Promise<AsyncIterator<SubTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SubTypeSubscriptionPayload {
  mutation: MutationType;
  node: SubType;
  updatedFields: String[];
  previousValues: SubTypePreviousValues;
}

export interface SubTypeSubscriptionPayloadPromise
  extends Promise<SubTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubTypePreviousValuesPromise>() => T;
}

export interface SubTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubTypePreviousValuesSubscription>() => T;
}

export interface SubType {
  id: ID_Output;
  name: String;
}

export interface SubTypePromise extends Promise<SubType>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SubTypeSubscription
  extends Promise<AsyncIterator<SubType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SuperTypeEdge {
  node: SuperType;
  cursor: String;
}

export interface SuperTypeEdgePromise
  extends Promise<SuperTypeEdge>,
    Fragmentable {
  node: <T = SuperTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SuperTypeEdgeSubscription
  extends Promise<AsyncIterator<SuperTypeEdge>>,
    Fragmentable {
  node: <T = SuperTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TokenPreviousValues {
  id: ID_Output;
  artist: String;
  borderColor: BorderColor;
  colorIdentities: Color[];
  colors: Color[];
  layout: Layout;
  name: String;
  number: String;
  power?: String;
  text?: String;
  toughness?: String;
  type: String;
  uuid: String;
  watermark?: String;
}

export interface TokenPreviousValuesPromise
  extends Promise<TokenPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  artist: () => Promise<String>;
  borderColor: () => Promise<BorderColor>;
  colorIdentities: () => Promise<Color[]>;
  colors: () => Promise<Color[]>;
  layout: () => Promise<Layout>;
  name: () => Promise<String>;
  number: () => Promise<String>;
  power: () => Promise<String>;
  text: () => Promise<String>;
  toughness: () => Promise<String>;
  type: () => Promise<String>;
  uuid: () => Promise<String>;
  watermark: () => Promise<String>;
}

export interface TokenPreviousValuesSubscription
  extends Promise<AsyncIterator<TokenPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  artist: () => Promise<AsyncIterator<String>>;
  borderColor: () => Promise<AsyncIterator<BorderColor>>;
  colorIdentities: () => Promise<AsyncIterator<Color[]>>;
  colors: () => Promise<AsyncIterator<Color[]>>;
  layout: () => Promise<AsyncIterator<Layout>>;
  name: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  power: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  toughness: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  uuid: () => Promise<AsyncIterator<String>>;
  watermark: () => Promise<AsyncIterator<String>>;
}

export interface Card {
  id: ID_Output;
  uuid: String;
  artist: String;
  colorIdentities: Color[];
  colors: Color[];
  layout: Layout;
  name: String;
  number: String;
  power?: String;
  toughness?: String;
  text?: String;
  type: String;
  watermark?: String;
  convertedManaCost: Float;
  flavorText?: String;
  foreignData?: <T = FragmentableArray<ForeignData>>() => T;
  manaCost: String;
  multiverseId: Int;
  rarity: Rarity;
  rulings?: <T = FragmentableArray<Ruling>>() => T;
  legalities?: Json;
}

export interface CardPromise extends Promise<Card>, Fragmentable {
  id: () => Promise<ID_Output>;
  set: <T = SetPromise>() => T;
  uuid: () => Promise<String>;
  artist: () => Promise<String>;
  colorIdentities: () => Promise<Color[]>;
  colors: () => Promise<Color[]>;
  layout: () => Promise<Layout>;
  name: () => Promise<String>;
  number: () => Promise<String>;
  power: () => Promise<String>;
  toughness: () => Promise<String>;
  text: () => Promise<String>;
  type: () => Promise<String>;
  watermark: () => Promise<String>;
  convertedManaCost: () => Promise<Float>;
  flavorText: () => Promise<String>;
  foreignData: <T = FragmentableArray<ForeignData>>() => T;
  manaCost: () => Promise<String>;
  multiverseId: () => Promise<Int>;
  rarity: () => Promise<Rarity>;
  rulings: <T = FragmentableArray<Ruling>>() => T;
  printings: <T = FragmentableArray<Printing>>(
    args?: {
      where?: PrintingWhereInput;
      orderBy?: PrintingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subTypes: <T = FragmentableArray<SubType>>(
    args?: {
      where?: SubTypeWhereInput;
      orderBy?: SubTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  superTypes: <T = FragmentableArray<SuperType>>(
    args?: {
      where?: SuperTypeWhereInput;
      orderBy?: SuperTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  types: <T = FragmentableArray<Type>>(
    args?: {
      where?: TypeWhereInput;
      orderBy?: TypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  legalities: () => Promise<Json>;
}

export interface CardSubscription
  extends Promise<AsyncIterator<Card>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  set: <T = SetSubscription>() => T;
  uuid: () => Promise<AsyncIterator<String>>;
  artist: () => Promise<AsyncIterator<String>>;
  colorIdentities: () => Promise<AsyncIterator<Color[]>>;
  colors: () => Promise<AsyncIterator<Color[]>>;
  layout: () => Promise<AsyncIterator<Layout>>;
  name: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  power: () => Promise<AsyncIterator<String>>;
  toughness: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  watermark: () => Promise<AsyncIterator<String>>;
  convertedManaCost: () => Promise<AsyncIterator<Float>>;
  flavorText: () => Promise<AsyncIterator<String>>;
  foreignData: <T = Promise<AsyncIterator<ForeignDataSubscription>>>() => T;
  manaCost: () => Promise<AsyncIterator<String>>;
  multiverseId: () => Promise<AsyncIterator<Int>>;
  rarity: () => Promise<AsyncIterator<Rarity>>;
  rulings: <T = Promise<AsyncIterator<RulingSubscription>>>() => T;
  printings: <T = Promise<AsyncIterator<PrintingSubscription>>>(
    args?: {
      where?: PrintingWhereInput;
      orderBy?: PrintingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subTypes: <T = Promise<AsyncIterator<SubTypeSubscription>>>(
    args?: {
      where?: SubTypeWhereInput;
      orderBy?: SubTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  superTypes: <T = Promise<AsyncIterator<SuperTypeSubscription>>>(
    args?: {
      where?: SuperTypeWhereInput;
      orderBy?: SuperTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  types: <T = Promise<AsyncIterator<TypeSubscription>>>(
    args?: {
      where?: TypeWhereInput;
      orderBy?: TypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  legalities: () => Promise<AsyncIterator<Json>>;
}

export interface SubTypeConnection {
  pageInfo: PageInfo;
  edges: SubTypeEdge[];
}

export interface SubTypeConnectionPromise
  extends Promise<SubTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubTypeEdge>>() => T;
  aggregate: <T = AggregateSubTypePromise>() => T;
}

export interface SubTypeConnectionSubscription
  extends Promise<AsyncIterator<SubTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubTypeSubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Json = any;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Set",
    embedded: false
  },
  {
    name: "Token",
    embedded: false
  },
  {
    name: "Card",
    embedded: false
  },
  {
    name: "ForeignData",
    embedded: true
  },
  {
    name: "Ruling",
    embedded: true
  },
  {
    name: "Printing",
    embedded: false
  },
  {
    name: "SubType",
    embedded: false
  },
  {
    name: "SuperType",
    embedded: false
  },
  {
    name: "Type",
    embedded: false
  },
  {
    name: "Color",
    embedded: false
  },
  {
    name: "Layout",
    embedded: false
  },
  {
    name: "BorderColor",
    embedded: false
  },
  {
    name: "SetType",
    embedded: false
  },
  {
    name: "Rarity",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
